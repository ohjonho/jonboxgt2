<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trivia Murder Party</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .screen {
            display: none;
            text-align: center;
            animation: fadeIn 0.3s ease-in;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1, h2 {
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 5px;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 120px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .secondary { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .success { background: linear-gradient(45deg, #00b894, #00a085); }
        .danger { background: linear-gradient(45deg, #e17055, #d63031); }

        input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            font-size: 1rem;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .room-code {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            letter-spacing: 3px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .item {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .option {
            width: 100%;
            padding: 15px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover { background: rgba(255, 255, 255, 0.3); border-color: #ffd700; }
        .option.selected { background: #ffd700; color: #333; border-color: #ffd700; }

        .timer {
            font-size: 3rem;
            font-weight: bold;
            color: #ff6b6b;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            max-width: 280px;
            margin: 20px auto;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
        }

        .grid-cell:hover { background: rgba(255, 255, 255, 0.4); border-color: #ffd700; }
        .grid-cell.selected { background: #ffd700; color: #333; }
        .grid-cell.winner { background: #00b894; color: white; }
        .grid-cell.loser { background: #e17055; color: white; }
        .grid-cell.collision { background: #ff6b6b; color: white; animation: pulse 0.5s ease-in-out; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .item.winner { background: linear-gradient(45deg, #ffd700, #ffed4e); color: #333; }
        .item.correct { background: rgba(0, 184, 148, 0.3); border-left: 4px solid #00b894; }
        .item.partially-correct { background: rgba(255, 193, 7, 0.3); border-left: 4px solid #ffc107; }
        .item.incorrect { background: rgba(225, 112, 85, 0.3); border-left: 4px solid #e17055; }

        .highlight {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-weight: bold;
        }

        .status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .status.w { background: #00b894; color: white; }
        .status.l { background: #e17055; color: white; }
        .status.powerup { background: linear-gradient(45deg, #a29bfe, #6c5ce7); color: white; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .api-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .api-status.working { background: #00b894; }
        .api-status.failed { background: #e17055; }
        .api-status.unknown { background: #ffd700; }

        .minigame-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .player-type {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .player-type.w { background: #00b894; color: white; }
        .player-type.l { background: #e17055; color: white; }

        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            background: #00b894;
            color: white;
        }

        @media (max-width: 480px) {
            .game-container { padding: 15px; }
            h1 { font-size: 1.5rem; }
            .room-code { font-size: 1.5rem; letter-spacing: 2px; }
            .timer { font-size: 2rem; }
            .grid { max-width: 250px; }
            .grid-cell { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">üåê Online</div>
    
    <!-- Username Modal -->
    <div class="modal" id="usernameModal">
        <div class="modal-content">
            <h2>Enter Username</h2>
            <input type="text" id="usernameModalInput" placeholder="Your username" maxlength="20">
            <div>
                <button onclick="confirmUsername()" id="confirmUsernameBtn">Create Room</button>
                <button onclick="closeUsernameModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="game-container">
        <!-- Home Screen -->
        <div class="screen active" id="homeScreen">
            <h1>üéØ Trivia Murder Party</h1>
            <button onclick="showUsernameModal()" id="createRoomBtn">Create Room</button>
            <button onclick="showJoinScreen()" class="secondary">Join Room</button>
            <div class="container">
                <h4>üåê Multiplayer Status:</h4>
                <div id="apiStatusDisplay">
                    <div><span class="api-status working"></span>Real-time multiplayer ready</div>
                </div>
            </div>
        </div>

        <!-- Join Room Screen -->
        <div class="screen" id="joinRoomScreen">
            <h2>Join Game</h2>
            <input type="text" id="roomCodeInput" placeholder="Enter 6-character room code" maxlength="6">
            <input type="text" id="usernameInput" placeholder="Enter your username">
            <button onclick="joinRoom()">Join Room</button>
            <button onclick="showHomeScreen()" class="secondary">Back</button>
        </div>

        <!-- Lobby Screen -->
        <div class="screen" id="lobbyScreen">
            <h2>Game Lobby</h2>
            <div class="room-code" id="roomCodeDisplay"></div>
            <div class="container" id="playerList"></div>
            <div class="container">
                <h4>Add Computer Player:</h4>
                <button onclick="addComputerPlayer('easy')" class="secondary" style="min-width: 80px; margin: 5px;">Easy AI</button>
                <button onclick="addComputerPlayer('medium')" class="secondary" style="min-width: 80px; margin: 5px;">Medium AI</button>
                <button onclick="addComputerPlayer('hard')" class="secondary" style="min-width: 80px; margin: 5px;">Hard AI</button>
            </div>
            <button onclick="shareRoom()" class="success">Share Room</button>
            <button onclick="startGame()" id="startGameBtn">Start Game</button>
            <button onclick="showHomeScreen()" class="danger">Leave Room</button>
        </div>

        <!-- Category Selection Screen -->
        <div class="screen" id="categoryScreen">
            <h2>Select Category</h2>
            <p>Round <span id="currentRound">1</span> of 6</p>
            <div id="categoryOptions"></div>
            <div class="timer" id="categoryTimer">10</div>
        </div>

        <!-- Question Screen -->
        <div class="screen" id="questionScreen">
            <h2>Round <span id="questionRound">1</span></h2>
            <div class="container">
                <div id="questionText" style="font-size: 1.1rem; margin-bottom: 20px; line-height: 1.4;"></div>
                <div id="answerOptions"></div>
            </div>
            <div class="timer" id="questionTimer">10</div>
        </div>

        <!-- Answers Screen -->
        <div class="screen" id="answersScreen">
            <h2>Round Results</h2>
            <div class="container" id="answersDisplay"></div>
            <button onclick="proceedToMinigame()">Continue to Minigame</button>
        </div>

        <!-- Hunting Season Minigame Screen -->
        <div class="screen" id="huntingSeasonScreen">
            <h2>üéØ Hunting Season</h2>
            <div class="minigame-info">
                <strong>Winners:</strong> Pick a square to hunt losers!<br>
                <strong>Losers:</strong> Pick a square to hide!<br>
                If you collide, winners steal 1 point!
            </div>
            <div class="container" id="huntingPlayerStatus"></div>
            <p id="huntingInstructions">Choose your square!</p>
            <div class="grid" id="huntingGrid"></div>
            <div class="timer" id="huntingTimer">10</div>
        </div>

        <!-- Quantum Leap Minigame Screen -->
        <div class="screen" id="quantumLeapScreen">
            <h2>üöÄ Quantum Leap</h2>
            <div class="minigame-info">
                <strong>Phase 1:</strong> Pick a position (1-10) to leap to<br>
                <strong>Phase 2:</strong> Place a trap on any position<br>
                <strong>Scoring:</strong> Highest 2 players without traps get 2pts/1pt
            </div>
            <div class="container" id="quantumPlayerStatus"></div>
            <p id="quantumInstructions">Choose your leap position!</p>
            <div id="quantumPositions"></div>
            <div class="timer" id="quantumTimer">10</div>
        </div>

        <!-- Resource Race Minigame Screen -->
        <div class="screen" id="resourceRaceScreen">
            <h2>‚öíÔ∏è Resource Race</h2>
            <div class="minigame-info">
                <strong>Goal:</strong> Build projects (5 resources = 5 points) or sabotage others<br>
                <strong>Sabotage:</strong> 1 resource = -2 points to target's projects<br>
                <strong>Turns:</strong> 3 turns to allocate your 10 resources
            </div>
            <div class="container" id="resourcePlayerStatus"></div>
            <p id="resourceInstructions">Turn 1: Allocate your resources!</p>
            <div id="resourceControls"></div>
            <div class="timer" id="resourceTimer">10</div>
        </div>

        <!-- Dice Duel Minigame Screen -->
        <div class="screen" id="diceDuelScreen">
            <h2>üé≤ Dice Duel</h2>
            <div class="minigame-info">
                <strong>Rules:</strong> 3 rounds, choose 1-3 dice to roll<br>
                <strong>Betting:</strong> Bet points on total dice value (optional)<br>
                <strong>Scoring:</strong> Win bet = +bet points, Lose = -bet points, No bet = dice sum
            </div>
            <div class="container" id="dicePlayerStatus"></div>
            <p id="diceInstructions">Round 1: Choose your dice and bet!</p>
            <div id="diceControls"></div>
            <div class="timer" id="diceTimer">10</div>
        </div>

        <!-- Codebreaker Minigame Screen -->
        <div class="screen" id="codebreakerScreen">
            <h2>üîê Codebreaker</h2>
            <div class="minigame-info">
                <strong>Goal:</strong> Crack the 4-symbol code (üî¥üü°üü¢üîµ)<br>
                <strong>Feedback:</strong> ‚úÖ = correct position, ‚ö™ = wrong position<br>
                <strong>Attempts:</strong> 8 total attempts for all players
            </div>
            <div class="container" id="codePlayerStatus"></div>
            <p id="codeInstructions">Your turn! Enter your 4-symbol guess:</p>
            <div id="codeControls"></div>
            <div id="codeHistory"></div>
            <div class="timer" id="codeTimer">15</div>
        </div>

        <!-- Minigame Results Screen -->
        <div class="screen" id="minigameResultsScreen">
            <h2>üéØ Hunting Results</h2>
            <div class="container" id="minigameResults"></div>
            <button onclick="showScoreboard()">Continue to Scoreboard</button>
        </div>

        <!-- Scoreboard Screen -->
        <div class="screen" id="scoreboardScreen">
            <h2>Scoreboard</h2>
            <div class="container" id="scoreboard"></div>
            <button onclick="nextRound()" id="nextRoundBtn">Next Round</button>
        </div>

        <!-- Final Round Screen -->
        <div class="screen" id="finalRoundScreen">
            <h2>Final Super Round!</h2>
            <div class="container">
                <div id="finalQuestionText" style="font-size: 1.1rem; margin-bottom: 20px; line-height: 1.4;"></div>
                <p><strong>Select exactly 2 correct answers!</strong></p>
                <div id="finalOptions"></div>
            </div>
            <div class="timer" id="finalTimer">15</div>
        </div>

        <!-- Final Answers Screen -->
        <div class="screen" id="finalAnswersScreen">
            <h2>Final Round Results</h2>
            <div class="container" id="finalAnswersDisplay"></div>
            <button onclick="showFinalResults()">View Final Scoreboard</button>
        </div>

        <!-- Final Results Screen -->
        <div class="screen" id="finalResultsScreen">
            <h2>üèÜ Final Results</h2>
            <div class="container" id="finalScoreboard"></div>
            <button onclick="playAgain()">Play Again</button>
            <button onclick="showHomeScreen()" class="secondary">Main Menu</button>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // ========================================
        // GLOBAL VARIABLES AND CONSTANTS
        // ========================================
        
        // Supabase Configuration - Fixed initialization
        const supabaseUrl = 'https://iftehkxnwnhuugqtatzq.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlmdGVoa3hud25odXVncXRhdHpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA5MTY0MjQsImV4cCI6MjA2NjQ5MjQyNH0.pfEUmJTCd1aNKLplV_qZdQagR1ZlqliCxMamUy6egrg';
        
        // Fixed Supabase client initialization
        const { createClient } = supabase;
        const supabaseClient = createClient(supabaseUrl, supabaseAnonKey);
        
        const CONSTANTS = {
            TIMER_DURATION: { category: 10, question: 10, hunting: 10, final: 15, quantum: 10, resource: 10, dice: 10, code: 15 },
            POWERUP_ROUND: 3,
            FINAL_ROUND: 6,
            GRID_SIZE: 16,
            MAX_PLAYERS: 12,
            MIN_PLAYERS: 2,
            POINTS: { correct: 2, finalFull: 8, finalPartial: 2 },
            API_RATE_LIMIT: 2000,
            MINIGAMES: ['hunting', 'quantum', 'resource', 'dice', 'codebreaker']
        };

        const COMPUTER_NAMES = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry", "Ivy", "Jack"];
        const CATEGORIES = ["Science", "History", "Geography", "Sports", "Entertainment", "Literature", "Art", "Technology", "Nature", "Mathematics"];

        // Expanded backup questions for better fallback
        const BACKUP_QUESTIONS = [
            { question: "What is the capital of Australia?", options: ["Sydney", "Melbourne", "Canberra", "Perth"], correct: 2, category: "Geography" },
            { question: "Which planet is known as the Red Planet?", options: ["Venus", "Mars", "Jupiter", "Saturn"], correct: 1, category: "Science" },
            { question: "Who painted the Mona Lisa?", options: ["Vincent van Gogh", "Pablo Picasso", "Leonardo da Vinci", "Michelangelo"], correct: 2, category: "Art" },
            { question: "What is the largest mammal in the world?", options: ["African Elephant", "Blue Whale", "Giraffe", "Polar Bear"], correct: 1, category: "Nature" },
            { question: "In which year did World War II end?", options: ["1944", "1945", "1946", "1947"], correct: 1, category: "History" },
            { question: "What is the smallest prime number?", options: ["0", "1", "2", "3"], correct: 2, category: "Mathematics" },
            { question: "Which Shakespeare play features Romeo and Juliet?", options: ["Hamlet", "Macbeth", "Romeo and Juliet", "Othello"], correct: 2, category: "Literature" },
            { question: "What is the chemical symbol for gold?", options: ["Go", "Gd", "Au", "Ag"], correct: 2, category: "Science" },
            { question: "Which country is home to Machu Picchu?", options: ["Chile", "Peru", "Bolivia", "Ecuador"], correct: 1, category: "Geography" },
            { question: "What is the fastest land animal?", options: ["Lion", "Cheetah", "Leopard", "Tiger"], correct: 1, category: "Nature" },
            { question: "Who wrote 'To Kill a Mockingbird'?", options: ["Harper Lee", "Mark Twain", "Ernest Hemingway", "F. Scott Fitzgerald"], correct: 0, category: "Literature" },
            { question: "What is the largest ocean on Earth?", options: ["Atlantic", "Indian", "Arctic", "Pacific"], correct: 3, category: "Geography" },
            { question: "Which element has the symbol 'O'?", options: ["Osmium", "Oxygen", "Opium", "Octane"], correct: 1, category: "Science" },
            { question: "In which sport would you perform a slam dunk?", options: ["Tennis", "Basketball", "Volleyball", "Football"], correct: 1, category: "Sports" },
            { question: "What year did the Titanic sink?", options: ["1910", "1911", "1912", "1913"], correct: 2, category: "History" },
            { question: "Which movie won the first Academy Award for Best Picture?", options: ["Wings", "Sunrise", "The Jazz Singer", "7th Heaven"], correct: 0, category: "Entertainment" },
            { question: "What is the square root of 144?", options: ["11", "12", "13", "14"], correct: 1, category: "Mathematics" },
            { question: "Which programming language was created by Guido van Rossum?", options: ["Java", "Python", "C++", "Ruby"], correct: 1, category: "Technology" },
            { question: "What is the smallest country in the world?", options: ["Monaco", "Vatican City", "San Marino", "Liechtenstein"], correct: 1, category: "Geography" },
            { question: "Who composed 'The Four Seasons'?", options: ["Mozart", "Bach", "Vivaldi", "Beethoven"], correct: 2, category: "Art" },
            { question: "What is the hardest natural substance on Earth?", options: ["Gold", "Iron", "Diamond", "Platinum"], correct: 2, category: "Science" },
            { question: "Which ancient wonder of the world was located in Alexandria?", options: ["Hanging Gardens", "Lighthouse", "Colossus", "Mausoleum"], correct: 1, category: "History" },
            { question: "What is the main ingredient in guacamole?", options: ["Tomato", "Avocado", "Lime", "Onion"], correct: 1, category: "Science" },
            { question: "Which continent has the most countries?", options: ["Asia", "Europe", "Africa", "South America"], correct: 2, category: "Geography" },
            { question: "What does 'www' stand for?", options: ["World Wide Web", "World Web Wide", "Wide World Web", "Web Wide World"], correct: 0, category: "Technology" },
            { question: "Who painted 'Starry Night'?", options: ["Picasso", "Van Gogh", "Monet", "Renoir"], correct: 1, category: "Art" },
            { question: "What is the currency of Japan?", options: ["Yuan", "Won", "Yen", "Ringgit"], correct: 2, category: "Geography" },
            { question: "Which organ in the human body produces insulin?", options: ["Liver", "Kidney", "Pancreas", "Heart"], correct: 2, category: "Science" },
            { question: "What is the longest river in the world?", options: ["Amazon", "Nile", "Mississippi", "Yangtze"], correct: 1, category: "Geography" },
            { question: "In Greek mythology, who is the king of the gods?", options: ["Apollo", "Zeus", "Poseidon", "Hades"], correct: 1, category: "History" }
        ];

        const FINAL_ROUND_QUESTION = {
            question: "Which of these are considered programming languages? (Select exactly 2 correct answers)",
            options: ["Python", "HTML", "JavaScript", "CSS", "SQL"],
            correct: [0, 2]
        };

        // API Configuration
        const TRIVIA_APIS = [
            {
                name: "The Trivia API",
                url: "https://the-trivia-api.com/v2/questions?limit=10",
                process: processTheTriviaApi,
                working: null
            },
            {
                name: "Open Trivia DB", 
                url: "https://opentdb.com/api.php?amount=10&difficulty=medium&type=multiple",
                process: processOpenTriviaApi,
                working: null
            },
            {
                name: "Trivia DB Backup",
                url: "https://opentdb.com/api.php?amount=5&difficulty=easy&type=multiple",
                process: processOpenTriviaApi,
                working: null
            }
        ];

        // DOM Element Cache for efficiency
        const DOM = {};

        // Game State
        let gameState = {
            room: null,
            players: [],
            currentPlayer: null,
            currentRound: 1,
            currentQuestion: null,
            selectedAnswers: [],
            minigameGrid: new Array(CONSTANTS.GRID_SIZE).fill(null),
            isHost: false,
            backupQuestions: [...BACKUP_QUESTIONS],
            apiQuestions: [],
            playerStatus: new Map(),
            powerups: new Map(),
            roundAnswers: new Map(),
            finalAnswers: new Map(),
            flags: new Set(),
            currentTimer: null,
            minigameSelections: new Map(),
            lastApiCall: 0,
            pendingUsername: null,
            supabaseSubscription: null,
            currentMinigame: null,
            minigameData: new Map(),
            quantumPositions: new Map(),
            quantumTraps: new Map(),
            resourceData: new Map(),
            diceData: new Map(),
            codeData: {
                secretCode: [],
                attempts: [],
                currentAttempt: 0,
                guessOrder: []
            }
        };

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warn' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            console.log(`${prefix} [${timestamp}] ${message}`);
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getRandomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function cacheDOM() {
            // Cache frequently used DOM elements
            DOM.screens = document.querySelectorAll('.screen');
            DOM.roomCodeDisplay = document.getElementById('roomCodeDisplay');
            DOM.playerList = document.getElementById('playerList');
            DOM.startGameBtn = document.getElementById('startGameBtn');
            DOM.apiStatusDisplay = document.getElementById('apiStatusDisplay');
            DOM.connectionStatus = document.getElementById('connectionStatus');
        }

        function updateConnectionStatus(status, message) {
            if (DOM.connectionStatus) {
                const statusEmoji = status === 'online' ? 'üåê' : status === 'offline' ? 'üì¥' : '‚ö†Ô∏è';
                DOM.connectionStatus.textContent = `${statusEmoji} ${message}`;
                DOM.connectionStatus.style.background = status === 'online' ? '#00b894' : status === 'offline' ? '#e17055' : '#f39c12';
            }
        }

        function showScreen(screenId) {
            log(`Switching to screen: ${screenId}`);
            
            // Clear any existing timer
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
                gameState.currentTimer = null;
            }
            
            // Hide all screens
            DOM.screens.forEach(screen => screen.classList.remove('active'));
            
            // Show target screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                log(`Successfully switched to ${screenId}`, 'success');
            } else {
                log(`Screen ${screenId} not found!`, 'error');
            }
        }

        function resetGameState() {
            log('Resetting game state...');
            
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
                gameState.currentTimer = null;
            }

            // Unsubscribe from Supabase if needed
            if (gameState.supabaseSubscription) {
                gameState.supabaseSubscription.unsubscribe();
                gameState.supabaseSubscription = null;
            }
            
            Object.assign(gameState, {
                room: null,
                players: [],
                currentPlayer: null,
                currentRound: 1,
                currentQuestion: null,
                selectedAnswers: [],
                isHost: false,
                minigameGrid: new Array(CONSTANTS.GRID_SIZE).fill(null),
                backupQuestions: [...BACKUP_QUESTIONS],
                apiQuestions: [],
                playerStatus: new Map(),
                powerups: new Map(),
                roundAnswers: new Map(),
                finalAnswers: new Map(),
                flags: new Set(),
                minigameSelections: new Map(),
                supabaseSubscription: null,
                currentMinigame: null,
                minigameData: new Map(),
                quantumPositions: new Map(),
                quantumTraps: new Map(),
                resourceData: new Map(),
                diceData: new Map(),
                codeData: {
                    secretCode: [],
                    attempts: [],
                    currentAttempt: 0,
                    guessOrder: []
                },
                currentMinigameTurn: 1,
                currentMinigameRound: 1,
                currentDiceCount: 0,
                currentBet: 0,
                currentCodeGuess: []
            });
            
            log('Game state reset complete', 'success');
        }

        // ========================================
        // SUPABASE MULTIPLAYER FUNCTIONS
        // ========================================

        async function testSupabaseConnection() {
            try {
                updateConnectionStatus('connecting', 'Connecting...');
                
                // Test the connection with a simple query
                const { data, error } = await supabaseClient
                    .from('rooms')
                    .select('count')
                    .limit(1);
                
                if (error) {
                    throw error;
                }
                
                updateConnectionStatus('online', 'Online');
                log('‚úÖ Supabase connection successful', 'success');
                return true;
            } catch (error) {
                updateConnectionStatus('offline', 'Offline Mode');
                log(`‚ùå Supabase connection failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function createRoom() {
            try {
                const username = gameState.pendingUsername;
                if (!username) {
                    log('No username provided', 'error');
                    return;
                }

                resetGameState();

                gameState.room = generateRoomCode();
                gameState.isHost = true;
                gameState.currentPlayer = {
                    id: `host_${Date.now()}`,
                    name: username,
                    score: 0,
                    correctAnswers: 0,
                    pointsStolen: 0,
                    isHost: true,
                    isOnline: true
                };

                // Try to create room in Supabase
                try {
                    const { data, error } = await supabaseClient
                        .from('rooms')
                        .insert([{ code: gameState.room, status: 'waiting' }]);
                    
                    if (error) throw error;

                    // Add host as player in Supabase
                    const { data: playerData, error: playerError } = await supabaseClient
                        .from('players')
                        .insert([{ 
                            room_code: gameState.room, 
                            username: username, 
                            is_host: true,
                            player_id: gameState.currentPlayer.id,
                            score: 0
                        }]);
                    
                    if (playerError) throw playerError;

                    // Subscribe to player updates BEFORE fetching
                    subscribeToPlayers(gameState.room);
                    
                    // Fetch initial player list to sync gameState.players
                    await syncPlayersFromDatabase();
                    
                    updateConnectionStatus('online', 'Room Created');
                    
                } catch (error) {
                    log(`Supabase error (using offline mode): ${error.message}`, 'warn');
                    updateConnectionStatus('offline', 'Offline Mode');
                    // Fallback to local mode
                    gameState.players = [gameState.currentPlayer];
                }

                log(`Room created: ${gameState.room}`, 'success');

                // Try to fetch API questions (don't wait)
                fetchQuestionsFromAnyApi().then(success => {
                    if (success) {
                        updateQuestionStatus();
                    }
                });

                showLobby();

            } catch (error) {
                log(`Error creating room: ${error.message}`, 'error');
                alert('Failed to create room. Please try again.');
                showScreen('homeScreen');
            }
        }

        async function joinRoom() {
            try {
                const roomCode = document.getElementById('roomCodeInput')?.value?.trim()?.toUpperCase();
                const username = document.getElementById('usernameInput')?.value?.trim();

                if (!roomCode || roomCode.length !== 6) {
                    alert('Please enter a valid 6-character room code.');
                    return;
                }
                if (!username) {
                    alert('Please enter your username.');
                    return;
                }

                // Try to check if room exists in Supabase
                try {
                    const { data: roomData, error: roomError } = await supabaseClient
                        .from('rooms')
                        .select('*')
                        .eq('code', roomCode)
                        .single();
                    
                    if (roomError || !roomData) {
                        alert('Room not found. Please check the code and try again.');
                        return;
                    }

                    // Set local game state first
                    resetGameState();
                    gameState.room = roomCode;
                    gameState.isHost = false;
                    gameState.currentPlayer = {
                        id: `player_${Date.now()}`,
                        name: username,
                        score: 0,
                        correctAnswers: 0,
                        pointsStolen: 0,
                        isHost: false,
                        isOnline: true
                    };

                    // Add player to Supabase
                    const { data: playerData, error: playerError } = await supabaseClient
                        .from('players')
                        .insert([{ 
                            room_code: roomCode, 
                            username: username,
                            is_host: false,
                            player_id: gameState.currentPlayer.id,
                            score: 0
                        }]);
                    
                    if (playerError) throw playerError;

                    // Subscribe to player updates
                    subscribeToPlayers(roomCode);
                    
                    // Sync players from database
                    await syncPlayersFromDatabase();
                    
                    updateConnectionStatus('online', 'Joined Room');

                } catch (error) {
                    log(`Supabase error (using offline mode): ${error.message}`, 'warn');
                    updateConnectionStatus('offline', 'Offline Mode');
                    // Set fallback state
                    resetGameState();
                    gameState.room = roomCode;
                    gameState.isHost = false;
                    gameState.currentPlayer = {
                        id: 'player',
                        name: username,
                        score: 0,
                        correctAnswers: 0,
                        pointsStolen: 0
                    };
                    gameState.players = [gameState.currentPlayer];
                }

                showLobby();

            } catch (error) {
                log(`Error joining room: ${error.message}`, 'error');
                alert('Failed to join room. Please try again.');
            }
        }

        function subscribeToPlayers(roomCode) {
            try {
                gameState.supabaseSubscription = supabaseClient
                    .channel(`players-${roomCode}`)
                    .on(
                        'postgres_changes',
                        { 
                            event: '*', 
                            schema: 'public', 
                            table: 'players', 
                            filter: `room_code=eq.${roomCode}` 
                        },
                        async (payload) => {
                            log(`Player update received: ${payload.eventType}`, 'info');
                            await syncPlayersFromDatabase();
                            updatePlayerList();
                        }
                    )
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            log('Successfully subscribed to player updates', 'success');
                            // Initial fetch after subscription
                            syncPlayersFromDatabase();
                        } else if (status === 'CHANNEL_ERROR') {
                            log('Error subscribing to player updates', 'error');
                            updateConnectionStatus('offline', 'Connection Error');
                        }
                    });
            } catch (error) {
                log(`Error setting up subscription: ${error.message}`, 'error');
                updateConnectionStatus('offline', 'Offline Mode');
            }
        }

        async function syncPlayersFromDatabase() {
            try {
                if (!gameState.room) return;
                
                const { data: players, error } = await supabaseClient
                    .from('players')
                    .select('*')
                    .eq('room_code', gameState.room);
                
                if (error) {
                    log(`Error fetching players: ${error.message}`, 'error');
                    return;
                }

                if (players) {
                    // Convert database players to game format
                    const onlinePlayers = players.map(dbPlayer => ({
                        id: dbPlayer.player_id || dbPlayer.username,
                        name: dbPlayer.username,
                        score: dbPlayer.score || 0,
                        correctAnswers: 0,
                        pointsStolen: 0,
                        isHost: dbPlayer.is_host || false,
                        isOnline: true
                    }));

                    // Merge online players with any local AI players
                    const aiPlayers = gameState.players?.filter(p => p.difficulty) || [];
                    
                    // Update the main players array
                    gameState.players = [...onlinePlayers, ...aiPlayers];
                    
                    // Ensure current player is in the list
                    if (gameState.currentPlayer && !gameState.players.find(p => p.id === gameState.currentPlayer.id)) {
                        gameState.players.push(gameState.currentPlayer);
                    }

                    log(`Synced ${onlinePlayers.length} online players + ${aiPlayers.length} AI players`, 'success');
                }
            } catch (error) {
                log(`Error syncing players: ${error.message}`, 'error');
            }
        }

        // ========================================
        // API FUNCTIONS (Previous implementation)
        // ========================================
        
        async function testAllApis() {
            log('üî¨ Testing all trivia APIs...');
            
            const results = [];
            
            for (const api of TRIVIA_APIS) {
                try {
                    log(`Testing ${api.name}...`);
                    
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), 5000)
                    );
                    
                    const fetchPromise = fetch(api.url, {
                        method: 'GET',
                        cache: 'no-cache'
                    });
                    
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const processed = api.process(data);
                        
                        if (processed && processed.length > 0) {
                            api.working = true;
                            results.push(`${api.name}: ‚úÖ Working (${processed.length} questions)`);
                            log(`${api.name} is working!`, 'success');
                        } else {
                            api.working = false;
                            results.push(`${api.name}: ‚ùå No valid questions`);
                            log(`${api.name} returned no valid questions`, 'warn');
                        }
                    } else {
                        api.working = false;
                        results.push(`${api.name}: ‚ùå HTTP ${response.status}`);
                        log(`${api.name} HTTP error: ${response.status}`, 'error');
                    }
                } catch (error) {
                    api.working = false;
                    const errorMsg = error.message === 'Timeout' ? 'Timeout' : 'Error';
                    results.push(`${api.name}: ‚ùå ${errorMsg}`);
                    log(`${api.name} failed: ${error.message}`, 'error');
                }
            }
            
            const workingApis = TRIVIA_APIS.filter(api => api.working).length;
            log(`API test complete: ${workingApis}/${TRIVIA_APIS.length} APIs working`, workingApis > 0 ? 'success' : 'warn');
        }

        async function fetchQuestionsFromAnyApi() {
            const now = Date.now();
            if (now - gameState.lastApiCall < CONSTANTS.API_RATE_LIMIT) {
                log(`Rate limit: waiting ${Math.ceil((CONSTANTS.API_RATE_LIMIT - (now - gameState.lastApiCall)) / 1000)} seconds`, 'warn');
                return false;
            }

            const workingApis = TRIVIA_APIS.filter(api => api.working === true);
            
            if (workingApis.length === 0) {
                log('No working APIs available', 'warn');
                return false;
            }

            for (const api of workingApis) {
                try {
                    log(`üåê Fetching questions from ${api.name}...`);
                    
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), 8000)
                    );
                    
                    const fetchPromise = fetch(api.url, {
                        method: 'GET',
                        cache: 'no-cache'
                    });
                    
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    gameState.lastApiCall = now;
                    
                    if (response.ok) {
                        const data = await response.json();
                        const processedQuestions = api.process(data);
                        
                        if (processedQuestions && processedQuestions.length > 0) {
                            gameState.apiQuestions = processedQuestions;
                            log(`‚úÖ Loaded ${processedQuestions.length} questions from ${api.name}`, 'success');
                            return true;
                        }
                    }
                } catch (error) {
                    log(`${api.name} failed: ${error.message}`, 'error');
                    api.working = false;
                }
            }
            
            return false;
        }

        // API Processors (same as before)
        function processTheTriviaApi(data) {
            try {
                if (!Array.isArray(data)) return [];
                
                return data.map(q => {
                    if (!q.question || !q.correctAnswer || !Array.isArray(q.incorrectAnswers)) return null;
                    
                    const allAnswers = [q.correctAnswer, ...q.incorrectAnswers];
                    const shuffledAnswers = shuffle(allAnswers);
                    const correctIndex = shuffledAnswers.indexOf(q.correctAnswer);
                    
                    const categoryMapping = {
                        'science': 'Science',
                        'history': 'History', 
                        'geography': 'Geography',
                        'sport_and_leisure': 'Sports',
                        'film_and_tv': 'Entertainment',
                        'arts_and_literature': 'Literature',
                        'food_and_drink': 'Science',
                        'general_knowledge': 'Science',
                        'music': 'Entertainment',
                        'society_and_culture': 'History'
                    };
                    
                    return {
                        question: q.question.text || q.question,
                        options: shuffledAnswers,
                        correct: correctIndex,
                        category: categoryMapping[q.category] || 'Science',
                        source: 'the-trivia-api'
                    };
                }).filter(q => q !== null);
            } catch (error) {
                log(`Error processing The Trivia API data: ${error.message}`, 'error');
                return [];
            }
        }

        function processOpenTriviaApi(data) {
            try {
                if (data.response_code !== 0 || !Array.isArray(data.results)) return [];
                
                return data.results.map(q => {
                    if (!q.question || !q.correct_answer || !Array.isArray(q.incorrect_answers)) return null;
                    
                    const decodeHtml = (html) => {
                        const txt = document.createElement('textarea');
                        txt.innerHTML = html;
                        return txt.value;
                    };
                    
                    const allAnswers = [
                        decodeHtml(q.correct_answer),
                        ...q.incorrect_answers.map(ans => decodeHtml(ans))
                    ];
                    
                    const shuffledAnswers = shuffle(allAnswers);
                    const correctIndex = shuffledAnswers.indexOf(decodeHtml(q.correct_answer));
                    
                    const categoryMapping = {
                        'Science: Computers': 'Technology',
                        'Science: Mathematics': 'Mathematics',
                        'Science: Nature': 'Nature',
                        'Science & Nature': 'Science',
                        'Entertainment: Video Games': 'Entertainment',
                        'Entertainment: Music': 'Entertainment',
                        'Entertainment: Film': 'Entertainment',
                        'Entertainment: Television': 'Entertainment',
                        'Entertainment: Books': 'Literature',
                        'Sports': 'Sports',
                        'History': 'History',
                        'Geography': 'Geography',
                        'General Knowledge': 'Science'
                    };
                    
                    return {
                        question: decodeHtml(q.question),
                        options: shuffledAnswers,
                        correct: correctIndex,
                        category: categoryMapping[q.category] || 'Science',
                        source: 'opentdb'
                    };
                }).filter(q => q !== null);
            } catch (error) {
                log(`Error processing Open Trivia DB data: ${error.message}`, 'error');
                return [];
            }
        }

        function getNextQuestion(preferredCategory = null) {
            // Try API questions first
            if (gameState.apiQuestions.length > 0) {
                let question;
                
                if (preferredCategory) {
                    const categoryIndex = gameState.apiQuestions.findIndex(q => q.category === preferredCategory);
                    if (categoryIndex !== -1) {
                        question = gameState.apiQuestions.splice(categoryIndex, 1)[0];
                        log(`Using API question from ${preferredCategory} (${question.source})`, 'success');
                        return question;
                    }
                }
                
                question = gameState.apiQuestions.shift();
                log(`Using API question from ${question.category} (${question.source})`, 'success');
                return question;
            }
            
            // Fallback to backup questions
            if (preferredCategory && gameState.backupQuestions.length > 0) {
                const categoryQuestions = gameState.backupQuestions.filter(q => q.category === preferredCategory);
                if (categoryQuestions.length > 0) {
                    const question = categoryQuestions[0];
                    gameState.backupQuestions = gameState.backupQuestions.filter(q => q !== question);
                    log(`Using backup question from ${preferredCategory}`, 'warn');
                    return question;
                }
            }
            
            if (gameState.backupQuestions.length > 0) {
                const question = gameState.backupQuestions.shift();
                log(`Using backup question from ${question.category}`, 'warn');
                return question;
            }
            
            // Ultimate fallback
            log('Using fallback math question', 'warn');
            return { 
                question: "What is 2 + 2?", 
                options: ["3", "4", "5", "6"], 
                correct: 1, 
                category: "Mathematics",
                source: 'fallback'
            };
        }

        // ========================================
        // MODAL FUNCTIONS
        // ========================================
        
        function showUsernameModal() {
            const modal = document.getElementById('usernameModal');
            const input = document.getElementById('usernameModalInput');
            
            if (modal && input) {
                modal.classList.add('active');
                input.value = '';
                input.focus();
                
                // Handle Enter key
                input.onkeypress = function(e) {
                    if (e.key === 'Enter') {
                        confirmUsername();
                    }
                };
            }
        }

        function closeUsernameModal() {
            const modal = document.getElementById('usernameModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function confirmUsername() {
            const input = document.getElementById('usernameModalInput');
            const username = input?.value?.trim();
            
            if (!username) {
                alert("Please enter a valid username");
                return;
            }
            
            if (username.length > 20) {
                alert("Username must be 20 characters or less");
                return;
            }
            
            gameState.pendingUsername = username;
            closeUsernameModal();
            createRoom();
        }

        // ========================================
        // GLOBAL FUNCTIONS (EXPOSED TO HTML)
        // ========================================

        function showJoinScreen() {
            showScreen('joinRoomScreen');
        }

        function showHomeScreen() {
            resetGameState();
            showScreen('homeScreen');
        }

        async function addComputerPlayer(difficulty = 'medium') {
            try {
                if (gameState.players.length >= CONSTANTS.MAX_PLAYERS) {
                    alert('Room is full! Maximum 12 players allowed.');
                    return;
                }
                
                const usedNames = new Set(gameState.players.map(p => p.name));
                const availableNames = COMPUTER_NAMES.filter(name => !usedNames.has(name));
                
                if (availableNames.length === 0) {
                    alert('No more computer player names available!');
                    return;
                }
                
                const computerName = getRandomElement(availableNames);
                const computerId = 'computer_' + Date.now();
                
                const difficultyEmoji = { easy: 'üü¢', medium: 'üü°', hard: 'üî¥' };
                const displayName = `${computerName} ${difficultyEmoji[difficulty]}`;
                
                const aiPlayer = {
                    id: computerId,
                    name: displayName,
                    score: 0,
                    correctAnswers: 0,
                    pointsStolen: 0,
                    difficulty: difficulty,
                    isOnline: false
                };
                
                gameState.players.push(aiPlayer);
                
                // Sync database if online
                if (gameState.supabaseSubscription && gameState.room) {
                    try {
                        await syncPlayersFromDatabase();
                    } catch (error) {
                        log(`Error syncing after adding AI player: ${error.message}`, 'warn');
                    }
                }
                
                updatePlayerList();
                updateStartButton();
                
                log(`Added ${difficulty} AI player: ${computerName}`, 'success');
                
            } catch (error) {
                log(`Error adding computer player: ${error.message}`, 'error');
            }
        }

        function shareRoom() {
            try {
                if (!gameState.room) {
                    alert('No room to share!');
                    return;
                }
                
                const shareText = `Join my Trivia Murder Party game! Room code: ${gameState.room}`;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareText)
                        .then(() => alert('Room code copied to clipboard!'))
                        .catch(() => alert(`Share this room code: ${gameState.room}`));
                } else {
                    alert(`Share this room code: ${gameState.room}`);
                }
            } catch (error) {
                log(`Error sharing room: ${error.message}`, 'error');
                alert(`Share this room code: ${gameState.room}`);
            }
        }

        async function startGame() {
            try {
                if (gameState.players.length < CONSTANTS.MIN_PLAYERS) {
                    alert('Need at least 2 players to start!');
                    return;
                }
                
                if (DOM.startGameBtn) {
                    DOM.startGameBtn.disabled = true;
                    DOM.startGameBtn.textContent = 'Loading Game...';
                }
                
                // Sync latest players from database if online
                if (gameState.supabaseSubscription && gameState.room) {
                    try {
                        await syncPlayersFromDatabase();
                        log(`Starting game with ${gameState.players.length} total players`, 'success');
                    } catch (error) {
                        log(`Error syncing players before game start: ${error.message}`, 'warn');
                    }
                }
                
                // Final check for minimum players
                if (gameState.players.length < CONSTANTS.MIN_PLAYERS) {
                    alert('Need at least 2 players to start!');
                    if (DOM.startGameBtn) {
                        DOM.startGameBtn.disabled = false;
                        DOM.startGameBtn.textContent = 'Start Game';
                    }
                    return;
                }
                
                // Try to fetch fresh questions
                fetchQuestionsFromAnyApi().then(success => {
                    if (success) {
                        log('Fresh API questions loaded for game start', 'success');
                    } else {
                        log('Using backup questions for game', 'warn');
                    }
                    
                    gameState.currentRound = 1;
                    showCategorySelection();
                });
                
            } catch (error) {
                log(`Error starting game: ${error.message}`, 'error');
                alert('Failed to start game. Please try again.');
                
                if (DOM.startGameBtn) {
                    DOM.startGameBtn.disabled = false;
                    DOM.startGameBtn.textContent = 'Start Game';
                }
            }
        }

        // ========================================
        // INTERNAL FUNCTIONS (Rest of game logic same as before)
        // ========================================
        
        function showLobby() {
            showScreen('lobbyScreen');
            
            if (DOM.roomCodeDisplay) {
                DOM.roomCodeDisplay.textContent = gameState.room;
            }
            
            updatePlayerList();
            updateStartButton();
            updateQuestionStatus();
        }

        function updatePlayerList() {
            if (!DOM.playerList) return;
            
            const fragment = document.createDocumentFragment();
            
            // Separate online and AI players
            const onlinePlayers = gameState.players.filter(p => p.isOnline !== false);
            const aiPlayers = gameState.players.filter(p => p.difficulty);
            
            const header = document.createElement('h3');
            
            if (gameState.supabaseSubscription && onlinePlayers.length > 0) {
                header.textContent = `üåê Players (${gameState.players.length}/${CONSTANTS.MAX_PLAYERS})`;
                
                // Show online players first
                if (onlinePlayers.length > 0) {
                    const onlineHeader = document.createElement('h4');
                    onlineHeader.textContent = `Online Players (${onlinePlayers.length}):`;
                    onlineHeader.style.marginTop = '10px';
                    fragment.appendChild(onlineHeader);
                    
                    onlinePlayers.forEach(player => {
                        const div = document.createElement('div');
                        div.className = 'item';
                        
                        const isCurrentPlayer = player.id === gameState.currentPlayer?.id;
                        const hostIndicator = player.isHost ? ' üëë' : '';
                        
                        let statusHTML = '';
                        if (gameState.powerups.has(player.id)) {
                            statusHTML += '<span class="status powerup">üí™</span>';
                        }
                        if (gameState.playerStatus.has(player.id)) {
                            const status = gameState.playerStatus.get(player.id);
                            statusHTML += `<span class="player-type ${status.toLowerCase()}">${status}</span>`;
                        }
                        
                        div.innerHTML = `
                            <span>${player.name}${isCurrentPlayer ? ' (You)' : ''}${hostIndicator}</span>
                            <span>${player.score || 0} pts ${statusHTML}</span>
                        `;
                        fragment.appendChild(div);
                    });
                }
                
                // Show AI players
                if (aiPlayers.length > 0) {
                    const aiHeader = document.createElement('h4');
                    aiHeader.textContent = `AI Players (${aiPlayers.length}):`;
                    aiHeader.style.marginTop = '10px';
                    fragment.appendChild(aiHeader);
                    
                    aiPlayers.forEach(player => {
                        const div = document.createElement('div');
                        div.className = 'item';
                        
                        let statusHTML = '';
                        if (gameState.powerups.has(player.id)) {
                            statusHTML += '<span class="status powerup">üí™</span>';
                        }
                        if (gameState.playerStatus.has(player.id)) {
                            const status = gameState.playerStatus.get(player.id);
                            statusHTML += `<span class="player-type ${status.toLowerCase()}">${status}</span>`;
                        }
                        
                        div.innerHTML = `
                            <span>${player.name}</span>
                            <span>${player.score} pts ${statusHTML}</span>
                        `;
                        fragment.appendChild(div);
                    });
                }
            } else {
                // Fallback to local player list
                header.textContent = `üì¥ Offline Players (${gameState.players.length}/${CONSTANTS.MAX_PLAYERS})`;
                
                gameState.players.forEach(player => {
                    const div = document.createElement('div');
                    div.className = 'item';
                    
                    let statusHTML = '';
                    if (gameState.powerups.has(player.id)) {
                        statusHTML += '<span class="status powerup">üí™</span>';
                    }
                    if (gameState.playerStatus.has(player.id)) {
                        const status = gameState.playerStatus.get(player.id);
                        statusHTML += `<span class="player-type ${status.toLowerCase()}">${status}</span>`;
                    }
                    
                    const isCurrentPlayer = player.id === gameState.currentPlayer?.id;
                    div.innerHTML = `
                        <span>${player.name}${isCurrentPlayer ? ' (You)' : ''}</span>
                        <span>${player.score} pts ${statusHTML}</span>
                    `;
                    fragment.appendChild(div);
                });
            }
            
            DOM.playerList.innerHTML = '';
            DOM.playerList.appendChild(header);
            DOM.playerList.appendChild(fragment);
        }

        function updateStartButton() {
            if (DOM.startGameBtn) {
                if (gameState.players.length >= CONSTANTS.MIN_PLAYERS) {
                    DOM.startGameBtn.disabled = false;
                    DOM.startGameBtn.textContent = 'Start Game';
                } else {
                    DOM.startGameBtn.disabled = true;
                    DOM.startGameBtn.textContent = `Start Game (${gameState.players.length}/${CONSTANTS.MIN_PLAYERS} players)`;
                }
            }
        }

        function updateQuestionStatus() {
            try {
                if (!DOM.playerList) return;
                
                // Remove existing status
                const existingStatus = DOM.playerList.querySelector('.question-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                const statusDiv = document.createElement('div');
                statusDiv.className = 'question-status';
                statusDiv.style.cssText = 'font-size: 0.9rem; opacity: 0.8; margin-top: 10px; text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                
                const apiCount = gameState.apiQuestions?.length || 0;
                const backupCount = gameState.backupQuestions?.length || 0;
                const workingApis = TRIVIA_APIS.filter(api => api.working === true).length;
                
                let statusText;
                if (apiCount > 0) {
                    statusText = `üåê ${apiCount} fresh questions loaded + ${backupCount} backup questions`;
                } else if (workingApis > 0) {
                    statusText = `üåê ${workingApis} APIs available + ${backupCount} backup questions`;
                } else {
                    statusText = `üìö Using ${backupCount} backup questions (APIs unavailable)`;
                }
                
                statusDiv.textContent = statusText;
                DOM.playerList.appendChild(statusDiv);
            } catch (error) {
                log(`Error updating question status: ${error.message}`, 'warn');
            }
        }

        // Rest of the game functions (category selection, questions, minigames, etc.) remain the same as in the previous version...
        // I'll include key functions for completeness:

        function showCategorySelection() {
            showScreen('categoryScreen');
            
            const currentRoundEl = document.getElementById('currentRound');
            if (currentRoundEl) {
                currentRoundEl.textContent = gameState.currentRound;
            }
            
            gameState.flags.clear();
            
            const categoryOptions = document.getElementById('categoryOptions');
            if (!categoryOptions) return;
            
            const shuffledCategories = shuffle(CATEGORIES).slice(0, 4);
            const fragment = document.createDocumentFragment();
            
            shuffledCategories.forEach(category => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = category;
                div.onclick = () => selectCategory(category);
                fragment.appendChild(div);
            });
            
            categoryOptions.innerHTML = '';
            categoryOptions.appendChild(fragment);
            
            startTimer('categoryTimer', CONSTANTS.TIMER_DURATION.category, () => {
                if (!gameState.flags.has('categorySelected')) {
                    selectCategory(getRandomElement(shuffledCategories));
                }
            });
        }

        function selectCategory(category) {
            if (gameState.flags.has('categorySelected')) return;
            gameState.flags.add('categorySelected');
            
            document.querySelectorAll('#categoryOptions .option').forEach(opt => opt.classList.remove('selected'));
            event?.target?.classList.add('selected');
            
            setTimeout(() => generateQuestion(category), 1000);
        }

        function generateQuestion(category) {
            const question = getNextQuestion(category);
            gameState.currentQuestion = question;
            showQuestion();
        }

        function showQuestion() {
            showScreen('questionScreen');
            
            const questionRoundEl = document.getElementById('questionRound');
            if (questionRoundEl) {
                questionRoundEl.textContent = gameState.currentRound;
            }
            
            const questionTextEl = document.getElementById('questionText');
            if (questionTextEl) {
                questionTextEl.textContent = gameState.currentQuestion.question;
            }
            
            const answerOptions = document.getElementById('answerOptions');
            if (!answerOptions) return;
            
            const fragment = document.createDocumentFragment();
            gameState.currentQuestion.options.forEach((option, index) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = option;
                div.onclick = () => selectAnswer(index);
                fragment.appendChild(div);
            });
            
            answerOptions.innerHTML = '';
            answerOptions.appendChild(fragment);
            
            startTimer('questionTimer', CONSTANTS.TIMER_DURATION.question, () => {
                if (!gameState.flags.has('answerSelected')) {
                    selectAnswer(Math.floor(Math.random() * 4));
                }
            });
        }

        function selectAnswer(index) {
            if (gameState.flags.has('answerSelected')) return;
            gameState.flags.add('answerSelected');
            
            document.querySelectorAll('#answerOptions .option').forEach(opt => opt.classList.remove('selected'));
            document.querySelectorAll('#answerOptions .option')[index]?.classList.add('selected');
            
            gameState.selectedAnswers = [index];
            setTimeout(() => processAnswers(), 1000);
        }

        function processAnswers() {
            const correct = gameState.currentQuestion.correct;
            const playerAnswered = gameState.selectedAnswers[0] === correct;
            
            gameState.roundAnswers.clear();
            gameState.roundAnswers.set(gameState.currentPlayer.id, { answer: gameState.selectedAnswers[0], correct: playerAnswered });
            
            if (playerAnswered) {
                gameState.currentPlayer.score += CONSTANTS.POINTS.correct;
                gameState.currentPlayer.correctAnswers++;
                gameState.playerStatus.set(gameState.currentPlayer.id, 'W');
                log('Player answered correctly!', 'success');
            } else {
                gameState.playerStatus.set(gameState.currentPlayer.id, 'L');
                log('Player answered incorrectly', 'warn');
            }
            
            // Simulate other players with difficulty-based AI
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    let randomCorrect;
                    
                    if (player.difficulty) {
                        const correctChances = { easy: 0.3, medium: 0.5, hard: 0.7 };
                        const correctChance = correctChances[player.difficulty] || 0.5;
                        randomCorrect = Math.random() < correctChance;
                    } else {
                        randomCorrect = Math.random() < 0.5;
                    }
                    
                    const randomAnswer = randomCorrect ? correct : Math.floor(Math.random() * 4);
                    
                    gameState.roundAnswers.set(player.id, { answer: randomAnswer, correct: randomCorrect });
                    
                    if (randomCorrect) {
                        player.score += CONSTANTS.POINTS.correct;
                        player.correctAnswers++;
                        gameState.playerStatus.set(player.id, 'W');
                    } else {
                        gameState.playerStatus.set(player.id, 'L');
                    }
                }
            });
            
            if (gameState.currentRound >= CONSTANTS.POWERUP_ROUND) {
                distributePowerups();
            }
            
            showAnswers();
        }

        function distributePowerups() {
            const sortedPlayers = [...gameState.players].sort((a, b) => a.score - b.score);
            const bottomQuarter = Math.ceil(sortedPlayers.length * 0.25);
            
            for (let i = 0; i < bottomQuarter; i++) {
                gameState.powerups.set(sortedPlayers[i].id, { type: 'extraTime', description: 'Extra Time' });
            }
        }

        function showAnswers() {
            showScreen('answersScreen');
            const answersDisplay = document.getElementById('answersDisplay');
            if (!answersDisplay) return;
            
            const fragment = document.createDocumentFragment();
            
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            highlight.innerHTML = `<strong>‚úÖ Correct Answer:</strong><br>${gameState.currentQuestion.options[gameState.currentQuestion.correct]}`;
            fragment.appendChild(highlight);
            
            const header = document.createElement('h3');
            header.textContent = 'Player Answers:';
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const playerAnswer = gameState.roundAnswers.get(player.id);
                if (!playerAnswer) return;
                
                const div = document.createElement('div');
                div.className = `item ${playerAnswer.correct ? 'correct' : 'incorrect'}`;
                const answerText = gameState.currentQuestion.options[playerAnswer.answer];
                const resultIcon = playerAnswer.correct ? '‚úÖ' : '‚ùå';
                
                div.innerHTML = `<span>${player.name}</span><span>${resultIcon} ${answerText}</span>`;
                fragment.appendChild(div);
            });
            
            answersDisplay.innerHTML = '';
            answersDisplay.appendChild(fragment);
        }

        function proceedToMinigame() {
            const winners = gameState.players.filter(p => gameState.playerStatus.get(p.id) === 'W');
            const losers = gameState.players.filter(p => gameState.playerStatus.get(p.id) === 'L');
            
            // Skip minigame if no winners or no losers (except for some minigames that work with any split)
            if (winners.length === 0 || losers.length === 0) {
                // Some minigames work with any player split
                const anyPlayerMinigames = ['resource', 'dice', 'codebreaker'];
                const selectedMinigame = CONSTANTS.MINIGAMES[(gameState.currentRound - 1) % CONSTANTS.MINIGAMES.length];
                
                if (!anyPlayerMinigames.includes(selectedMinigame)) {
                    log('Skipping minigame - no valid W/L split and minigame requires it', 'warn');
                    setTimeout(() => {
                        gameState.playerStatus.clear();
                        showScoreboard();
                    }, 2000);
                    return;
                }
            }
            
            // Select minigame based on round (rotating through all 5)
            const minigameIndex = (gameState.currentRound - 1) % CONSTANTS.MINIGAMES.length;
            const selectedMinigame = CONSTANTS.MINIGAMES[minigameIndex];
            gameState.currentMinigame = selectedMinigame;
            
            log(`Starting ${selectedMinigame} minigame (${winners.length} winners vs ${losers.length} losers)`, 'success');
            
            switch (selectedMinigame) {
                case 'hunting':
                    showHuntingSeasonMinigame();
                    break;
                case 'quantum':
                    showQuantumLeapMinigame();
                    break;
                case 'resource':
                    showResourceRaceMinigame();
                    break;
                case 'dice':
                    showDiceDuelMinigame();
                    break;
                case 'codebreaker':
                    showCodebreakerMinigame();
                    break;
                default:
                    showHuntingSeasonMinigame();
            }
        }

        function showHuntingSeasonMinigame() {
            showScreen('huntingSeasonScreen');
            gameState.minigameSelections.clear();
            
            updateHuntingPlayerStatus();
            createHuntingGrid();
            
            const playerType = gameState.playerStatus.get(gameState.currentPlayer.id);
            const instructions = document.getElementById('huntingInstructions');
            if (instructions) {
                if (playerType === 'W') {
                    instructions.textContent = "You're hunting! Pick a square to catch the losers!";
                    instructions.style.color = '#00b894';
                } else {
                    instructions.textContent = "You're being hunted! Pick a square to hide!";
                    instructions.style.color = '#e17055';
                }
            }
            
            startTimer('huntingTimer', CONSTANTS.TIMER_DURATION.hunting, () => {
                if (!gameState.minigameSelections.has(gameState.currentPlayer.id)) {
                    // Auto-select random square if player didn't choose
                    const randomSquare = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                    selectHuntingSquare(randomSquare);
                }
            });
        }

        function updateHuntingPlayerStatus() {
            const huntingPlayerStatus = document.getElementById('huntingPlayerStatus');
            if (!huntingPlayerStatus) return;
            
            const fragment = document.createDocumentFragment();
            
            const winnersDiv = document.createElement('div');
            winnersDiv.innerHTML = '<h4>üèπ Hunters (Winners):</h4>';
            const winnersContainer = document.createElement('div');
            
            const losersDiv = document.createElement('div');
            losersDiv.innerHTML = '<h4>üéØ Hunted (Losers):</h4>';
            const losersContainer = document.createElement('div');
            
            gameState.players.forEach(player => {
                const status = gameState.playerStatus.get(player.id);
                const div = document.createElement('div');
                div.className = 'item';
                div.innerHTML = `<span>${player.name}</span><span>${player.score} pts</span>`;
                
                if (status === 'W') {
                    div.style.background = 'rgba(0, 184, 148, 0.3)';
                    winnersContainer.appendChild(div);
                } else if (status === 'L') {
                    div.style.background = 'rgba(225, 112, 85, 0.3)';
                    losersContainer.appendChild(div);
                }
            });
            
            fragment.appendChild(winnersDiv);
            fragment.appendChild(winnersContainer);
            fragment.appendChild(losersDiv);
            fragment.appendChild(losersContainer);
            
            huntingPlayerStatus.innerHTML = '';
            huntingPlayerStatus.appendChild(fragment);
        }

        function createHuntingGrid() {
            const huntingGrid = document.getElementById('huntingGrid');
            if (!huntingGrid) return;
            
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = i + 1;
                cell.onclick = () => selectHuntingSquare(i);
                fragment.appendChild(cell);
            }
            
            huntingGrid.innerHTML = '';
            huntingGrid.appendChild(fragment);
        }

        function selectHuntingSquare(index) {
            if (gameState.minigameSelections.has(gameState.currentPlayer.id)) return;
            
            // Clear previous selection visuals
            document.querySelectorAll('#huntingGrid .grid-cell').forEach(cell => cell.classList.remove('selected'));
            
            // Mark current selection
            const selectedCell = document.querySelectorAll('#huntingGrid .grid-cell')[index];
            if (selectedCell) {
                selectedCell.classList.add('selected');
            }
            
            gameState.minigameSelections.set(gameState.currentPlayer.id, index);
            log(`Player selected square ${index + 1}`, 'success');
            
            // Simulate AI player selections
            simulateAIMinigameSelections();
            
            // Process results after slight delay
            setTimeout(() => processMinigameResults(), 1500);
        }

        function simulateAIMinigameSelections() {
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id && !gameState.minigameSelections.has(player.id)) {
                    // AI makes strategic choices based on difficulty
                    let choice;
                    if (player.difficulty === 'hard') {
                        // Hard AI tries to avoid corners and center
                        const avoidSquares = [0, 3, 12, 15, 5, 6, 9, 10]; // corners and center-ish
                        const safeSquares = Array.from({length: CONSTANTS.GRID_SIZE}, (_, i) => i).filter(i => !avoidSquares.includes(i));
                        choice = getRandomElement(safeSquares);
                    } else if (player.difficulty === 'easy') {
                        // Easy AI just picks randomly
                        choice = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                    } else {
                        // Medium AI has some strategy
                        choice = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                        if (Math.random() < 0.3) { // 30% chance to pick edge squares
                            const edgeSquares = [1, 2, 4, 7, 8, 11, 13, 14];
                            choice = getRandomElement(edgeSquares);
                        }
                    }
                    
                    gameState.minigameSelections.set(player.id, choice);
                }
            });
        }

        function processMinigameResults() {
            const results = [];
            const winnerSelections = new Map();
            const loserSelections = new Map();
            
            // Separate selections by player type
            gameState.players.forEach(player => {
                const selection = gameState.minigameSelections.get(player.id);
                const status = gameState.playerStatus.get(player.id);
                
                if (status === 'W') {
                    winnerSelections.set(player.id, selection);
                } else if (status === 'L') {
                    loserSelections.set(player.id, selection);
                }
            });
            
            // Check for collisions
            winnerSelections.forEach((winnerSquare, winnerId) => {
                loserSelections.forEach((loserSquare, loserId) => {
                    if (winnerSquare === loserSquare) {
                        // Collision! Winner steals from loser
                        const winner = gameState.players.find(p => p.id === winnerId);
                        const loser = gameState.players.find(p => p.id === loserId);
                        
                        if (loser.score > 0) {
                            loser.score -= 1;
                            winner.score += 1;
                            winner.pointsStolen = (winner.pointsStolen || 0) + 1;
                            results.push(`${winner.name} caught ${loser.name} on square ${winnerSquare + 1}! (1 point stolen)`);
                        } else {
                            winner.score += 1;
                            winner.pointsStolen = (winner.pointsStolen || 0) + 1;
                            results.push(`${winner.name} caught ${loser.name} on square ${winnerSquare + 1}! (1 point gained)`);
                        }
                    }
                });
            });
            
            if (results.length === 0) {
                results.push('No collisions! All players escaped safely.');
            }
            
            showMinigameResults(results, winnerSelections, loserSelections);
        }

        // ========================================
        // RESOURCE RACE MINIGAME
        // ========================================
        
        function showResourceRaceMinigame() {
            showScreen('resourceRaceScreen');
            gameState.resourceData.clear();
            gameState.flags.clear();
            
            // Initialize player resources
            gameState.players.forEach(player => {
                gameState.resourceData.set(player.id, {
                    resources: 10,
                    projects: 0,
                    sabotages: new Map(),
                    turn: 1
                });
            });
            
            gameState.currentMinigameTurn = 1;
            updateResourcePlayerStatus();
            createResourceControls();
            
            startTimer('resourceTimer', CONSTANTS.TIMER_DURATION.resource, () => {
                autoAllocateResources();
            });
        }

        function updateResourcePlayerStatus() {
            const resourcePlayerStatus = document.getElementById('resourcePlayerStatus');
            if (!resourcePlayerStatus) return;
            
            const fragment = document.createDocumentFragment();
            const header = document.createElement('h3');
            header.textContent = `Turn ${gameState.currentMinigameTurn}/3`;
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const data = gameState.resourceData.get(player.id);
                const div = document.createElement('div');
                div.className = 'item';
                div.innerHTML = `
                    <span>${player.name}</span>
                    <span>Resources: ${data.resources}, Projects: ${data.projects}</span>
                `;
                fragment.appendChild(div);
            });
            
            resourcePlayerStatus.innerHTML = '';
            resourcePlayerStatus.appendChild(fragment);
        }

        function createResourceControls() {
            const resourceControls = document.getElementById('resourceControls');
            if (!resourceControls) return;
            
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            const fragment = document.createDocumentFragment();
            
            const resourcesDiv = document.createElement('div');
            resourcesDiv.innerHTML = `<h4>Available Resources: <span id="availableResources">${playerData.resources}</span></h4>`;
            fragment.appendChild(resourcesDiv);
            
            // Build Project button
            const buildDiv = document.createElement('div');
            buildDiv.style.margin = '10px 0';
            buildDiv.innerHTML = `
                <button id="buildProjectBtn" class="success">Build Project (5 resources = 5 points)</button>
            `;
            fragment.appendChild(buildDiv);
            
            // Sabotage section
            const sabotageDiv = document.createElement('div');
            sabotageDiv.innerHTML = '<h4>Sabotage Players:</h4>';
            
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    const sabotageBtn = document.createElement('button');
                    sabotageBtn.className = 'danger';
                    sabotageBtn.textContent = `Sabotage ${player.name} (1 resource = -2 to their projects)`;
                    sabotageBtn.style.margin = '5px';
                    sabotageBtn.style.fontSize = '0.9rem';
                    sabotageBtn.onclick = () => sabotagePlayer(player.id);
                    sabotageDiv.appendChild(sabotageBtn);
                }
            });
            
            fragment.appendChild(sabotageDiv);
            
            const finishDiv = document.createElement('div');
            finishDiv.style.margin = '15px 0';
            finishDiv.innerHTML = `<button id="finishTurnBtn" class="secondary">Finish Turn</button>`;
            fragment.appendChild(finishDiv);
            
            resourceControls.innerHTML = '';
            resourceControls.appendChild(fragment);
            
            // Add event listeners
            document.getElementById('buildProjectBtn').onclick = buildProject;
            document.getElementById('finishTurnBtn').onclick = finishResourceTurn;
            
            updateResourceButtons();
        }

        function buildProject() {
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            if (playerData.resources >= 5) {
                playerData.resources -= 5;
                playerData.projects += 1;
                updateResourceDisplay();
                updateResourceButtons();
                log('Built a project!', 'success');
            }
        }

        function sabotagePlayer(targetId) {
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            if (playerData.resources >= 1) {
                playerData.resources -= 1;
                
                const currentSabotage = playerData.sabotages.get(targetId) || 0;
                playerData.sabotages.set(targetId, currentSabotage + 1);
                
                updateResourceDisplay();
                updateResourceButtons();
                
                const targetPlayer = gameState.players.find(p => p.id === targetId);
                log(`Sabotaged ${targetPlayer.name}!`, 'success');
            }
        }

        function updateResourceDisplay() {
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            const availableEl = document.getElementById('availableResources');
            if (availableEl) {
                availableEl.textContent = playerData.resources;
            }
            updateResourcePlayerStatus();
        }

        function updateResourceButtons() {
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            const buildBtn = document.getElementById('buildProjectBtn');
            if (buildBtn) {
                buildBtn.disabled = playerData.resources < 5;
            }
            
            document.querySelectorAll('#resourceControls .danger').forEach(btn => {
                btn.disabled = playerData.resources < 1;
            });
        }

        function finishResourceTurn() {
            // Simulate AI player turns
            simulateAIResourceTurns();
            
            gameState.currentMinigameTurn++;
            
            if (gameState.currentMinigameTurn <= 3) {
                // Next turn
                updateResourcePlayerStatus();
                createResourceControls();
                
                const instructions = document.getElementById('resourceInstructions');
                if (instructions) {
                    instructions.textContent = `Turn ${gameState.currentMinigameTurn}: Allocate your resources!`;
                }
                
                startTimer('resourceTimer', CONSTANTS.TIMER_DURATION.resource, () => {
                    autoAllocateResources();
                });
            } else {
                // End minigame
                processResourceResults();
            }
        }

        function simulateAIResourceTurns() {
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    const playerData = gameState.resourceData.get(player.id);
                    
                    // AI strategy based on difficulty
                    let strategy = 'balanced';
                    if (player.difficulty === 'easy') strategy = 'random';
                    else if (player.difficulty === 'hard') strategy = 'optimal';
                    
                    while (playerData.resources > 0) {
                        if (strategy === 'optimal' && playerData.resources >= 5) {
                            // Build projects first
                            playerData.resources -= 5;
                            playerData.projects += 1;
                        } else if (strategy === 'balanced' && Math.random() < 0.7 && playerData.resources >= 5) {
                            // Build projects most of the time
                            playerData.resources -= 5;
                            playerData.projects += 1;
                        } else if (playerData.resources >= 1 && Math.random() < 0.3) {
                            // Sometimes sabotage
                            const targets = gameState.players.filter(p => p.id !== player.id);
                            const target = getRandomElement(targets);
                            playerData.resources -= 1;
                            const currentSab = playerData.sabotages.get(target.id) || 0;
                            playerData.sabotages.set(target.id, currentSab + 1);
                        } else {
                            break;
                        }
                    }
                }
            });
        }

        function autoAllocateResources() {
            // Auto-allocate remaining resources if player didn't finish
            const playerData = gameState.resourceData.get(gameState.currentPlayer.id);
            while (playerData.resources >= 5) {
                playerData.resources -= 5;
                playerData.projects += 1;
            }
            finishResourceTurn();
        }

        function processResourceResults() {
            const results = [];
            
            gameState.players.forEach(player => {
                const playerData = gameState.resourceData.get(player.id);
                let projectPoints = playerData.projects * 5;
                
                // Apply sabotage damage
                gameState.players.forEach(other => {
                    if (other.id !== player.id) {
                        const otherData = gameState.resourceData.get(other.id);
                        const sabotageCount = otherData.sabotages.get(player.id) || 0;
                        projectPoints -= sabotageCount * 2;
                    }
                });
                
                projectPoints = Math.max(0, projectPoints); // Can't go negative
                player.score += projectPoints;
                
                results.push({
                    player: player.name,
                    projects: playerData.projects,
                    basePoints: playerData.projects * 5,
                    sabotageReceived: (playerData.projects * 5) - projectPoints,
                    finalPoints: projectPoints
                });
            });
            
            showResourceResults(results);
        }

        function showResourceResults(results) {
            showScreen('minigameResultsScreen');
            
            const minigameResults = document.getElementById('minigameResults');
            if (!minigameResults) return;
            
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = '‚öíÔ∏è Resource Race Results';
            fragment.appendChild(header);
            
            results.forEach(result => {
                const div = document.createElement('div');
                div.className = 'item';
                div.innerHTML = `
                    <div>
                        <strong>${result.player}</strong><br>
                        <small>Projects: ${result.projects} | Base: ${result.basePoints} | Sabotaged: -${result.sabotageReceived}</small>
                    </div>
                    <span>+${result.finalPoints} pts</span>
                `;
                fragment.appendChild(div);
            });
            
            minigameResults.innerHTML = '';
            minigameResults.appendChild(fragment);
        }
            showScreen('minigameResultsScreen');
            
            const minigameResults = document.getElementById('minigameResults');
            if (!minigameResults) return;
            
            const fragment = document.createDocumentFragment();
            
            // Show the grid with results
            const gridContainer = document.createElement('div');
            gridContainer.innerHTML = '<h3>Final Grid Results:</h3>';
            
            const resultGrid = document.createElement('div');
            resultGrid.className = 'grid';
            resultGrid.style.margin = '15px auto';
            
            for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = i + 1;
                
                // Check if square was selected
                const winnerHere = Array.from(winnerSelections.entries()).find(([_, square]) => square === i);
                const loserHere = Array.from(loserSelections.entries()).find(([_, square]) => square === i);
                
                if (winnerHere && loserHere) {
                    cell.classList.add('collision');
                    cell.textContent = 'üí•';
                } else if (winnerHere) {
                    cell.classList.add('winner');
                    cell.textContent = 'üèπ';
                } else if (loserHere) {
                    cell.classList.add('loser');
                    cell.textContent = 'üéØ';
                }
                
                resultGrid.appendChild(cell);
            }
            
            gridContainer.appendChild(resultGrid);
            fragment.appendChild(gridContainer);
            
            // Show results text
            const resultsHeader = document.createElement('h3');
            resultsHeader.textContent = 'Hunt Results:';
            fragment.appendChild(resultsHeader);
            
            results.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'highlight';
                resultDiv.style.fontSize = '0.9rem';
                resultDiv.textContent = result;
                fragment.appendChild(resultDiv);
            });
            
            minigameResults.innerHTML = '';
            minigameResults.appendChild(fragment);
            
            // Clear selections for next round
            gameState.minigameSelections.clear();
        }

        function showScoreboard() {
            showScreen('scoreboardScreen');
            updateScoreboard();
            
            const nextBtn = document.getElementById('nextRoundBtn');
            if (nextBtn) {
                if (gameState.currentRound >= CONSTANTS.FINAL_ROUND) {
                    nextBtn.textContent = 'Final Round';
                    nextBtn.onclick = () => showFinalRound();
                } else {
                    nextBtn.textContent = 'Next Round';
                    nextBtn.onclick = () => nextRound();
                }
            }
        }

        function updateScoreboard() {
            const scoreboard = document.getElementById('scoreboard');
            if (!scoreboard) return;
            
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = `Round ${gameState.currentRound} Standings`;
            fragment.appendChild(header);
            
            sortedPlayers.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `item ${index === 0 ? 'winner' : ''}`;
                
                const powerupHTML = gameState.powerups.has(player.id) ? '<span class="status powerup">üí™</span>' : '';
                
                div.innerHTML = `
                    <span>${index + 1}. ${player.name}</span>
                    <span>${player.score} pts ${powerupHTML}</span>
                `;
                fragment.appendChild(div);
            });
            
            scoreboard.innerHTML = '';
            scoreboard.appendChild(fragment);
        }

        function nextRound() {
            gameState.currentRound++;
            gameState.selectedAnswers = [];
            gameState.playerStatus.clear(); // Clear W/L status for next round
            
            // Clear minigame data from previous round
            gameState.minigameSelections.clear();
            gameState.quantumPositions.clear();
            gameState.quantumTraps.clear();
            gameState.resourceData.clear();
            gameState.diceData.clear();
            gameState.codeData = {
                secretCode: [],
                attempts: [],
                currentAttempt: 0,
                guessOrder: []
            };
            gameState.currentMinigame = null;
            gameState.currentMinigameTurn = 1;
            gameState.currentMinigameRound = 1;
            gameState.currentDiceCount = 0;
            gameState.currentBet = 0;
            gameState.currentCodeGuess = [];
            
            log(`Starting Round ${gameState.currentRound}`, 'success');
            showCategorySelection();
        }

        function showFinalRound() {
            showScreen('finalRoundScreen');
            
            const finalQuestionText = document.getElementById('finalQuestionText');
            if (finalQuestionText) {
                finalQuestionText.textContent = FINAL_ROUND_QUESTION.question;
            }
            
            const finalOptions = document.getElementById('finalOptions');
            if (!finalOptions) return;
            
            const fragment = document.createDocumentFragment();
            FINAL_ROUND_QUESTION.options.forEach((option, index) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = option;
                div.onclick = () => selectFinalAnswer(index);
                fragment.appendChild(div);
            });
            
            finalOptions.innerHTML = '';
            finalOptions.appendChild(fragment);
            
            gameState.selectedAnswers = [];
            
            startTimer('finalTimer', CONSTANTS.TIMER_DURATION.final, () => {
                if (gameState.selectedAnswers.length === 0) {
                    // Auto-select two random answers
                    const randomAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                    gameState.selectedAnswers = randomAnswers;
                }
                processFinalAnswers();
            });
        }

        function selectFinalAnswer(index) {
            if (gameState.selectedAnswers.includes(index)) {
                // Deselect
                gameState.selectedAnswers = gameState.selectedAnswers.filter(a => a !== index);
                document.querySelectorAll('#finalOptions .option')[index].classList.remove('selected');
            } else if (gameState.selectedAnswers.length < 2) {
                // Select (max 2)
                gameState.selectedAnswers.push(index);
                document.querySelectorAll('#finalOptions .option')[index].classList.add('selected');
            }
            
            // Auto-proceed if exactly 2 selected
            if (gameState.selectedAnswers.length === 2) {
                setTimeout(() => processFinalAnswers(), 1000);
            }
        }

        function processFinalAnswers() {
            const correctAnswers = FINAL_ROUND_QUESTION.correct;
            const playerCorrect = gameState.selectedAnswers.filter(a => correctAnswers.includes(a)).length;
            
            let points = 0;
            if (playerCorrect === 2) {
                points = CONSTANTS.POINTS.finalFull;
            } else if (playerCorrect === 1) {
                points = CONSTANTS.POINTS.finalPartial;
            }
            
            gameState.currentPlayer.score += points;
            gameState.finalAnswers.set(gameState.currentPlayer.id, { 
                answers: gameState.selectedAnswers, 
                correct: playerCorrect, 
                points: points 
            });
            
            // Simulate other players
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    let aiAnswers;
                    if (player.difficulty === 'hard') {
                        // Hard AI has 70% chance to get both right
                        if (Math.random() < 0.7) {
                            aiAnswers = [...correctAnswers];
                        } else if (Math.random() < 0.8) {
                            aiAnswers = [correctAnswers[0], Math.floor(Math.random() * 5)];
                        } else {
                            aiAnswers = [Math.floor(Math.random() * 5), Math.floor(Math.random() * 5)];
                        }
                    } else if (player.difficulty === 'easy') {
                        // Easy AI mostly random
                        aiAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                    } else {
                        // Medium AI has 40% chance to get both right
                        if (Math.random() < 0.4) {
                            aiAnswers = [...correctAnswers];
                        } else if (Math.random() < 0.6) {
                            aiAnswers = [correctAnswers[0], Math.floor(Math.random() * 5)];
                        } else {
                            aiAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                        }
                    }
                    
                    const aiCorrect = aiAnswers.filter(a => correctAnswers.includes(a)).length;
                    let aiPoints = 0;
                    if (aiCorrect === 2) {
                        aiPoints = CONSTANTS.POINTS.finalFull;
                    } else if (aiCorrect === 1) {
                        aiPoints = CONSTANTS.POINTS.finalPartial;
                    }
                    
                    player.score += aiPoints;
                    gameState.finalAnswers.set(player.id, { 
                        answers: aiAnswers, 
                        correct: aiCorrect, 
                        points: aiPoints 
                    });
                }
            });
            
            showFinalAnswers();
        }

        function showFinalAnswers() {
            showScreen('finalAnswersScreen');
            
            const finalAnswersDisplay = document.getElementById('finalAnswersDisplay');
            if (!finalAnswersDisplay) return;
            
            const fragment = document.createDocumentFragment();
            
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            const correctOptions = FINAL_ROUND_QUESTION.correct.map(i => FINAL_ROUND_QUESTION.options[i]);
            highlight.innerHTML = `<strong>‚úÖ Correct Answers:</strong><br>${correctOptions.join(' and ')}`;
            fragment.appendChild(highlight);
            
            const header = document.createElement('h3');
            header.textContent = 'Final Round Results:';
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const playerResult = gameState.finalAnswers.get(player.id);
                if (!playerResult) return;
                
                const div = document.createElement('div');
                let className = 'item ';
                if (playerResult.correct === 2) {
                    className += 'correct';
                } else if (playerResult.correct === 1) {
                    className += 'partially-correct';
                } else {
                    className += 'incorrect';
                }
                div.className = className;
                
                const playerAnswers = playerResult.answers.map(i => FINAL_ROUND_QUESTION.options[i]);
                const resultText = `${playerResult.correct}/2 correct (+${playerResult.points} pts)`;
                
                div.innerHTML = `
                    <div>
                        <strong>${player.name}</strong><br>
                        <small>${playerAnswers.join(', ')}</small>
                    </div>
                    <span>${resultText}</span>
                `;
                fragment.appendChild(div);
            });
            
            finalAnswersDisplay.innerHTML = '';
            finalAnswersDisplay.appendChild(fragment);
        }

        function showFinalResults() {
            showScreen('finalResultsScreen');
            
            const finalScoreboard = document.getElementById('finalScoreboard');
            if (!finalScoreboard) return;
            
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = 'üèÜ Championship Results';
            fragment.appendChild(header);
            
            sortedPlayers.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `item ${index === 0 ? 'winner' : ''}`;
                
                const rank = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                
                div.innerHTML = `
                    <div>
                        <strong>${rank} ${player.name}</strong>
                        <br>
                        <small>Correct: ${player.correctAnswers} | Stolen: ${player.pointsStolen || 0}</small>
                    </div>
                    <div>
                        <strong>${player.score} pts</strong>
                    </div>
                `;
                fragment.appendChild(div);
            });
            
            finalScoreboard.innerHTML = '';
            finalScoreboard.appendChild(fragment);
        }

        function playAgain() {
            if (confirm('Start a new game with the same players?')) {
                // Reset player scores but keep players
                gameState.players.forEach(player => {
                    player.score = 0;
                    player.correctAnswers = 0;
                    player.pointsStolen = 0;
                });
                
                // Reset game round data
                gameState.currentRound = 1;
                gameState.playerStatus.clear();
                gameState.powerups.clear();
                gameState.backupQuestions = [...BACKUP_QUESTIONS];
                
                // Reset minigame data
                gameState.minigameSelections.clear();
                gameState.quantumPositions.clear();
                gameState.quantumTraps.clear();
                gameState.resourceData.clear();
                gameState.diceData.clear();
                gameState.codeData = {
                    secretCode: [],
                    attempts: [],
                    currentAttempt: 0,
                    guessOrder: []
                };
                gameState.currentMinigame = null;
                gameState.currentMinigameTurn = 1;
                gameState.currentMinigameRound = 1;
                
                // Fetch fresh questions
                fetchQuestionsFromAnyApi();
                
                showLobby();
            }
        }

        function startTimer(timerId, seconds, callback) {
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
            }
            
            const timerElement = document.getElementById(timerId);
            if (!timerElement) return;
            
            let timeLeft = seconds;
            
            // Apply powerup if available
            if (gameState.powerups.has(gameState.currentPlayer?.id)) {
                const powerup = gameState.powerups.get(gameState.currentPlayer.id);
                if (powerup.type === 'extraTime') {
                    timeLeft += 5;
                    gameState.powerups.delete(gameState.currentPlayer.id);
                    log('Extra time powerup applied!', 'success');
                }
            }
            
            timerElement.textContent = timeLeft;
            timerElement.style.color = '#ff6b6b';
            
            gameState.currentTimer = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(gameState.currentTimer);
                    gameState.currentTimer = null;
                    callback();
                }
            }, 1000);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        
        document.addEventListener('DOMContentLoaded', () => {
            log('üéÆ Trivia Murder Party Loading...');
            
            // Cache DOM elements
            cacheDOM();
            
            // Test Supabase connection
            testSupabaseConnection();
            
            // Check critical elements
            const criticalElements = ['homeScreen', 'lobbyScreen', 'categoryScreen', 'questionScreen'];
            const missingElements = criticalElements.filter(id => !document.getElementById(id));
            
            if (missingElements.length > 0) {
                log(`Missing critical elements: ${missingElements.join(', ')}`, 'error');
                return;
            }
            
            // Handle URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            if (roomCode) {
                const roomInput = document.getElementById('roomCodeInput');
                if (roomInput) {
                    roomInput.value = roomCode;
                    showScreen('joinRoomScreen');
                }
            }
            
            // Test all APIs on load
            setTimeout(() => {
                testAllApis();
            }, 1000);
            
            log('üéÆ Trivia Murder Party Initialized!', 'success');
        });

        // Global error handlers
        window.addEventListener('error', (event) => {
            log(`Global error: ${event.error?.message || event.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            log(`Unhandled promise rejection: ${event.reason}`, 'error');
        });

        // Prevent zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) event.preventDefault();
            lastTouchEnd = now;
        }, { passive: false });

        // Page visibility handling
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    log('Game paused (page hidden)');
                }
            } else {
                log('Game resumed (page visible)');
            }
        });
    </script>
</body>
</html>
