<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trivia Murder Party</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .screen {
            display: none;
            text-align: center;
            animation: fadeIn 0.3s ease-in;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1, h2 {
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 5px;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 120px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .secondary { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .success { background: linear-gradient(45deg, #00b894, #00a085); }
        .danger { background: linear-gradient(45deg, #e17055, #d63031); }

        input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            font-size: 1rem;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .room-code {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            letter-spacing: 3px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .item {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .option {
            width: 100%;
            padding: 15px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover { background: rgba(255, 255, 255, 0.3); border-color: #ffd700; }
        .option.selected { background: #ffd700; color: #333; border-color: #ffd700; }

        .timer {
            font-size: 3rem;
            font-weight: bold;
            color: #ff6b6b;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            max-width: 280px;
            margin: 20px auto;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
        }

        .grid-cell:hover { background: rgba(255, 255, 255, 0.4); border-color: #ffd700; }
        .grid-cell.selected { background: #ffd700; color: #333; }
        .grid-cell.winner { background: #00b894; color: white; }
        .grid-cell.loser { background: #e17055; color: white; }
        .grid-cell.collision { background: #ff6b6b; color: white; animation: pulse 0.5s ease-in-out; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .item.winner { background: linear-gradient(45deg, #ffd700, #ffed4e); color: #333; }
        .item.correct { background: rgba(0, 184, 148, 0.3); border-left: 4px solid #00b894; }
        .item.partially-correct { background: rgba(255, 193, 7, 0.3); border-left: 4px solid #ffc107; }
        .item.incorrect { background: rgba(225, 112, 85, 0.3); border-left: 4px solid #e17055; }

        .highlight {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-weight: bold;
        }

        .status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .status.w { background: #00b894; color: white; }
        .status.l { background: #e17055; color: white; }
        .status.powerup { background: linear-gradient(45deg, #a29bfe, #6c5ce7); color: white; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .api-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .api-status.working { background: #00b894; }
        .api-status.failed { background: #e17055; }
        .api-status.unknown { background: #ffd700; }

        .minigame-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .player-type {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .player-type.w { background: #00b894; color: white; }
        .player-type.l { background: #e17055; color: white; }

        @media (max-width: 480px) {
            .game-container { padding: 15px; }
            h1 { font-size: 1.5rem; }
            .room-code { font-size: 1.5rem; letter-spacing: 2px; }
            .timer { font-size: 2rem; }
            .grid { max-width: 250px; }
            .grid-cell { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <!-- Username Modal -->
    <div class="modal" id="usernameModal">
        <div class="modal-content">
            <h2>Enter Username</h2>
            <input type="text" id="usernameModalInput" placeholder="Your username" maxlength="20">
            <div>
                <button onclick="confirmUsername()" id="confirmUsernameBtn">Create Room</button>
                <button onclick="closeUsernameModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="game-container">
        <!-- Home Screen -->
        <div class="screen active" id="homeScreen">
            <h1>🎯 Trivia Murder Party</h1>
            <button onclick="showUsernameModal()" id="createRoomBtn">Create Room</button>
            <button onclick="showJoinScreen()" class="secondary">Join Room</button>
            <div class="container">
                <h4>API Status:</h4>
                <div id="apiStatusDisplay">
                    <div><span class="api-status unknown"></span>Testing APIs...</div>
                </div>
            </div>
        </div>

        <!-- Join Room Screen -->
        <div class="screen" id="joinRoomScreen">
            <h2>Join Game</h2>
            <input type="text" id="roomCodeInput" placeholder="Enter 6-character room code" maxlength="6">
            <input type="text" id="usernameInput" placeholder="Enter your username">
            <button onclick="joinRoom()">Join Room</button>
            <button onclick="showHomeScreen()" class="secondary">Back</button>
        </div>

        <!-- Lobby Screen -->
        <div class="screen" id="lobbyScreen">
            <h2>Game Lobby</h2>
            <div class="room-code" id="roomCodeDisplay"></div>
            <div class="container" id="playerList"></div>
            <div class="container">
                <h4>Add Computer Player:</h4>
                <button onclick="addComputerPlayer('easy')" class="secondary" style="min-width: 80px; margin: 5px;">Easy AI</button>
                <button onclick="addComputerPlayer('medium')" class="secondary" style="min-width: 80px; margin: 5px;">Medium AI</button>
                <button onclick="addComputerPlayer('hard')" class="secondary" style="min-width: 80px; margin: 5px;">Hard AI</button>
            </div>
            <button onclick="shareRoom()" class="success">Share Room</button>
            <button onclick="startGame()" id="startGameBtn">Start Game</button>
            <button onclick="showHomeScreen()" class="danger">Leave Room</button>
        </div>

        <!-- Category Selection Screen -->
        <div class="screen" id="categoryScreen">
            <h2>Select Category</h2>
            <p>Round <span id="currentRound">1</span> of 6</p>
            <div id="categoryOptions"></div>
            <div class="timer" id="categoryTimer">10</div>
        </div>

        <!-- Question Screen -->
        <div class="screen" id="questionScreen">
            <h2>Round <span id="questionRound">1</span></h2>
            <div class="container">
                <div id="questionText" style="font-size: 1.1rem; margin-bottom: 20px; line-height: 1.4;"></div>
                <div id="answerOptions"></div>
            </div>
            <div class="timer" id="questionTimer">10</div>
        </div>

        <!-- Answers Screen -->
        <div class="screen" id="answersScreen">
            <h2>Round Results</h2>
            <div class="container" id="answersDisplay"></div>
            <button onclick="proceedToMinigame()">Continue to Minigame</button>
        </div>

        <!-- Hunting Season Minigame Screen -->
        <div class="screen" id="huntingSeasonScreen">
            <h2>🎯 Hunting Season</h2>
            <div class="minigame-info">
                <strong>Winners:</strong> Pick a square to hunt losers!<br>
                <strong>Losers:</strong> Pick a square to hide!<br>
                If you collide, winners steal 1 point!
            </div>
            <div class="container" id="huntingPlayerStatus"></div>
            <p id="huntingInstructions">Choose your square!</p>
            <div class="grid" id="huntingGrid"></div>
            <div class="timer" id="huntingTimer">10</div>
        </div>

        <!-- Minigame Results Screen -->
        <div class="screen" id="minigameResultsScreen">
            <h2>🎯 Hunting Results</h2>
            <div class="container" id="minigameResults"></div>
            <button onclick="showScoreboard()">Continue to Scoreboard</button>
        </div>

        <!-- Scoreboard Screen -->
        <div class="screen" id="scoreboardScreen">
            <h2>Scoreboard</h2>
            <div class="container" id="scoreboard"></div>
            <button onclick="nextRound()" id="nextRoundBtn">Next Round</button>
        </div>

        <!-- Final Round Screen -->
        <div class="screen" id="finalRoundScreen">
            <h2>Final Super Round!</h2>
            <div class="container">
                <div id="finalQuestionText" style="font-size: 1.1rem; margin-bottom: 20px; line-height: 1.4;"></div>
                <p><strong>Select exactly 2 correct answers!</strong></p>
                <div id="finalOptions"></div>
            </div>
            <div class="timer" id="finalTimer">15</div>
        </div>

        <!-- Final Answers Screen -->
        <div class="screen" id="finalAnswersScreen">
            <h2>Final Round Results</h2>
            <div class="container" id="finalAnswersDisplay"></div>
            <button onclick="showFinalResults()">View Final Scoreboard</button>
        </div>

        <!-- Final Results Screen -->
        <div class="screen" id="finalResultsScreen">
            <h2>🏆 Final Results</h2>
            <div class="container" id="finalScoreboard"></div>
            <button onclick="playAgain()">Play Again</button>
            <button onclick="showHomeScreen()" class="secondary">Main Menu</button>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js">
// ====== REAL-TIME SUBSCRIPTIONS AND SUPABASE SYNC PATCHES ======

// Subscribe helpers
function subscribeToGameState(roomCode) {
  supabase
    .channel('game_state')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.phase = payload.new.phase;
        renderPhaseScreen(payload.new.phase);
      })
    .subscribe();
}

function subscribeToMinigamePicks(roomCode) {
  supabase
    .channel('minigame_picks')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'minigame_picks', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.minigameSelections.set(payload.new.player_id, payload.new.pick);
        checkAllPicksAndContinue?.(); // Define this handler
      })
    .subscribe();
}

function subscribeToAnswers(roomCode) {
  supabase
    .channel('answers')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'answers', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.roundAnswers.set(payload.new.player_id, { answer: payload.new.answer, correct: payload.new.correct });
        maybeAdvancePhaseIfAllAnswered?.(); // Define this handler
      })
    .subscribe();
}

// Call these subscriptions on join/create
// After subscribeToPlayers(gameState.room);
subscribeToGameState(gameState.room);
subscribeToMinigamePicks(gameState.room);
subscribeToAnswers(gameState.room);

</script>

    <script>
        // ========================================
        // GLOBAL VARIABLES AND CONSTANTS
        // ========================================
        // Replace these values with your actual Supabase project info!
        const supabaseUrl = 'https://iftehkxnwnhuugqtatzq.supabase.co';
	const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlmdGVoa3hud25odXVncXRhdHpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA5MTY0MjQsImV4cCI6MjA2NjQ5MjQyNH0.pfEUmJTCd1aNKLplV_qZdQagR1ZlqliCxMamUy6egrg';
  	const supabase = supabase.createClient(supabaseUrl, supabaseAnonKey);
        const CONSTANTS = {
            TIMER_DURATION: { category: 10, question: 10, hunting: 10, final: 15 },
            POWERUP_ROUND: 3,
            FINAL_ROUND: 6,
            GRID_SIZE: 16,
            MAX_PLAYERS: 12,
            MIN_PLAYERS: 2,
            POINTS: { correct: 2, finalFull: 8, finalPartial: 2 },
            API_RATE_LIMIT: 2000 // Reduced rate limit for better performance
        };

        const COMPUTER_NAMES = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry", "Ivy", "Jack"];
        const CATEGORIES = ["Science", "History", "Geography", "Sports", "Entertainment", "Literature", "Art", "Technology", "Nature", "Mathematics"];

        // Expanded backup questions for better fallback
        const BACKUP_QUESTIONS = [
            { question: "What is the capital of Australia?", options: ["Sydney", "Melbourne", "Canberra", "Perth"], correct: 2, category: "Geography" },
            { question: "Which planet is known as the Red Planet?", options: ["Venus", "Mars", "Jupiter", "Saturn"], correct: 1, category: "Science" },
            { question: "Who painted the Mona Lisa?", options: ["Vincent van Gogh", "Pablo Picasso", "Leonardo da Vinci", "Michelangelo"], correct: 2, category: "Art" },
            { question: "What is the largest mammal in the world?", options: ["African Elephant", "Blue Whale", "Giraffe", "Polar Bear"], correct: 1, category: "Nature" },
            { question: "In which year did World War II end?", options: ["1944", "1945", "1946", "1947"], correct: 1, category: "History" },
            { question: "What is the smallest prime number?", options: ["0", "1", "2", "3"], correct: 2, category: "Mathematics" },
            { question: "Which Shakespeare play features Romeo and Juliet?", options: ["Hamlet", "Macbeth", "Romeo and Juliet", "Othello"], correct: 2, category: "Literature" },
            { question: "What is the chemical symbol for gold?", options: ["Go", "Gd", "Au", "Ag"], correct: 2, category: "Science" },
            { question: "Which country is home to Machu Picchu?", options: ["Chile", "Peru", "Bolivia", "Ecuador"], correct: 1, category: "Geography" },
            { question: "What is the fastest land animal?", options: ["Lion", "Cheetah", "Leopard", "Tiger"], correct: 1, category: "Nature" },
            { question: "Who wrote 'To Kill a Mockingbird'?", options: ["Harper Lee", "Mark Twain", "Ernest Hemingway", "F. Scott Fitzgerald"], correct: 0, category: "Literature" },
            { question: "What is the largest ocean on Earth?", options: ["Atlantic", "Indian", "Arctic", "Pacific"], correct: 3, category: "Geography" },
            { question: "Which element has the symbol 'O'?", options: ["Osmium", "Oxygen", "Opium", "Octane"], correct: 1, category: "Science" },
            { question: "In which sport would you perform a slam dunk?", options: ["Tennis", "Basketball", "Volleyball", "Football"], correct: 1, category: "Sports" },
            { question: "What year did the Titanic sink?", options: ["1910", "1911", "1912", "1913"], correct: 2, category: "History" },
            { question: "Which movie won the first Academy Award for Best Picture?", options: ["Wings", "Sunrise", "The Jazz Singer", "7th Heaven"], correct: 0, category: "Entertainment" },
            { question: "What is the square root of 144?", options: ["11", "12", "13", "14"], correct: 1, category: "Mathematics" },
            { question: "Which programming language was created by Guido van Rossum?", options: ["Java", "Python", "C++", "Ruby"], correct: 1, category: "Technology" },
            { question: "What is the smallest country in the world?", options: ["Monaco", "Vatican City", "San Marino", "Liechtenstein"], correct: 1, category: "Geography" },
            { question: "Who composed 'The Four Seasons'?", options: ["Mozart", "Bach", "Vivaldi", "Beethoven"], correct: 2, category: "Art" },
            { question: "What is the hardest natural substance on Earth?", options: ["Gold", "Iron", "Diamond", "Platinum"], correct: 2, category: "Science" },
            { question: "Which ancient wonder of the world was located in Alexandria?", options: ["Hanging Gardens", "Lighthouse", "Colossus", "Mausoleum"], correct: 1, category: "History" },
            { question: "What is the main ingredient in guacamole?", options: ["Tomato", "Avocado", "Lime", "Onion"], correct: 1, category: "Science" },
            { question: "Which continent has the most countries?", options: ["Asia", "Europe", "Africa", "South America"], correct: 2, category: "Geography" },
            { question: "What does 'www' stand for?", options: ["World Wide Web", "World Web Wide", "Wide World Web", "Web Wide World"], correct: 0, category: "Technology" },
            { question: "Who painted 'Starry Night'?", options: ["Picasso", "Van Gogh", "Monet", "Renoir"], correct: 1, category: "Art" },
            { question: "What is the currency of Japan?", options: ["Yuan", "Won", "Yen", "Ringgit"], correct: 2, category: "Geography" },
            { question: "Which organ in the human body produces insulin?", options: ["Liver", "Kidney", "Pancreas", "Heart"], correct: 2, category: "Science" },
            { question: "What is the longest river in the world?", options: ["Amazon", "Nile", "Mississippi", "Yangtze"], correct: 1, category: "Geography" },
            { question: "In Greek mythology, who is the king of the gods?", options: ["Apollo", "Zeus", "Poseidon", "Hades"], correct: 1, category: "History" }
        ];

        const FINAL_ROUND_QUESTION = {
            question: "Which of these are considered programming languages? (Select exactly 2 correct answers)",
            options: ["Python", "HTML", "JavaScript", "CSS", "SQL"],
            correct: [0, 2]
        };

        // Improved API Configuration (Fixed AbortSignal issue)
        const TRIVIA_APIS = [
            {
                name: "The Trivia API",
                url: "https://the-trivia-api.com/v2/questions?limit=10",
                process: processTheTriviaApi,
                working: null
            },
            {
                name: "Open Trivia DB", 
                url: "https://opentdb.com/api.php?amount=10&difficulty=medium&type=multiple",
                process: processOpenTriviaApi,
                working: null
            },
            {
                name: "Trivia DB Backup",
                url: "https://opentdb.com/api.php?amount=5&difficulty=easy&type=multiple",
                process: processOpenTriviaApi,
                working: null
            }
        ];

        // DOM Element Cache for efficiency
        const DOM = {};

        // Game State
        let gameState = {
            room: null,
            players: [],
            currentPlayer: null,
            currentRound: 1,
            currentQuestion: null,
            selectedAnswers: [],
            minigameGrid: new Array(CONSTANTS.GRID_SIZE).fill(null),
            isHost: false,
            backupQuestions: [...BACKUP_QUESTIONS],
            apiQuestions: [],
            playerStatus: new Map(),
            powerups: new Map(),
            roundAnswers: new Map(),
            finalAnswers: new Map(),
            flags: new Set(),
            currentTimer: null,
            minigameSelections: new Map(),
            lastApiCall: 0,
            pendingUsername: null
        };

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : type === 'warn' ? '⚠️' : 'ℹ️';
            console.log(`${prefix} [${timestamp}] ${message}`);
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getRandomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function cacheDOM() {
            // Cache frequently used DOM elements
            DOM.screens = document.querySelectorAll('.screen');
            DOM.roomCodeDisplay = document.getElementById('roomCodeDisplay');
            DOM.playerList = document.getElementById('playerList');
            DOM.startGameBtn = document.getElementById('startGameBtn');
            DOM.apiStatusDisplay = document.getElementById('apiStatusDisplay');
        }

        function showScreen(screenId) {
            log(`Switching to screen: ${screenId}`);
            
            // Clear any existing timer
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
                gameState.currentTimer = null;
            }
            
            // Hide all screens
            DOM.screens.forEach(screen => screen.classList.remove('active'));
            
            // Show target screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                log(`Successfully switched to ${screenId}`, 'success');
            } else {
                log(`Screen ${screenId} not found!`, 'error');
            }
        }

        function resetGameState() {
            log('Resetting game state...');
            
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
                gameState.currentTimer = null;
            }
            
            Object.assign(gameState, {
                room: null,
                players: [],
                currentPlayer: null,
                currentRound: 1,
                currentQuestion: null,
                selectedAnswers: [],
                isHost: false,
                minigameGrid: new Array(CONSTANTS.GRID_SIZE).fill(null),
                backupQuestions: [...BACKUP_QUESTIONS],
                apiQuestions: [],
                playerStatus: new Map(),
                powerups: new Map(),
                roundAnswers: new Map(),
                finalAnswers: new Map(),
                flags: new Set(),
                minigameSelections: new Map()
            });
            
            log('Game state reset complete', 'success');
        }

        // ========================================
        // IMPROVED API FUNCTIONS (Fixed AbortSignal issue)
        // ========================================
        
        async function testAllApis() {
            log('🔬 Testing all trivia APIs...');
            updateApiStatus('Testing APIs...', 'unknown');
            
            const results = [];
            
            for (const api of TRIVIA_APIS) {
                try {
                    log(`Testing ${api.name}...`);
                    
                    // Removed AbortController to fix cloning issue
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), 5000)
                    );
                    
                    const fetchPromise = fetch(api.url, {
                        method: 'GET',
                        cache: 'no-cache'
                    });
                    
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const processed = api.process(data);
                        
                        if (processed && processed.length > 0) {
                            api.working = true;
                            results.push(`${api.name}: ✅ Working (${processed.length} questions)`);
                            log(`${api.name} is working!`, 'success');
                        } else {
                            api.working = false;
                            results.push(`${api.name}: ❌ No valid questions`);
                            log(`${api.name} returned no valid questions`, 'warn');
                        }
                    } else {
                        api.working = false;
                        results.push(`${api.name}: ❌ HTTP ${response.status}`);
                        log(`${api.name} HTTP error: ${response.status}`, 'error');
                    }
                } catch (error) {
                    api.working = false;
                    const errorMsg = error.message === 'Timeout' ? 'Timeout' : 'Error';
                    results.push(`${api.name}: ❌ ${errorMsg}`);
                    log(`${api.name} failed: ${error.message}`, 'error');
                }
            }
            
            updateApiStatus(results.join('<br>'), 'tested');
            
            const workingApis = TRIVIA_APIS.filter(api => api.working).length;
            log(`API test complete: ${workingApis}/${TRIVIA_APIS.length} APIs working`, workingApis > 0 ? 'success' : 'warn');
        }

        function updateApiStatus(message, status) {
            if (DOM.apiStatusDisplay) {
                const statusClass = status === 'tested' ? '' : status === 'unknown' ? 'unknown' : 'failed';
                DOM.apiStatusDisplay.innerHTML = `<div><span class="api-status ${statusClass}"></span>${message}</div>`;
            }
        }

        async function fetchQuestionsFromAnyApi() {
            const now = Date.now();
            if (now - gameState.lastApiCall < CONSTANTS.API_RATE_LIMIT) {
                log(`Rate limit: waiting ${Math.ceil((CONSTANTS.API_RATE_LIMIT - (now - gameState.lastApiCall)) / 1000)} seconds`, 'warn');
                return false;
            }

            const workingApis = TRIVIA_APIS.filter(api => api.working === true);
            
            if (workingApis.length === 0) {
                log('No working APIs available', 'warn');
                return false;
            }

            for (const api of workingApis) {
                try {
                    log(`🌐 Fetching questions from ${api.name}...`);
                    
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), 8000)
                    );
                    
                    const fetchPromise = fetch(api.url, {
                        method: 'GET',
                        cache: 'no-cache'
                    });
                    
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    gameState.lastApiCall = now;
                    
                    if (response.ok) {
                        const data = await response.json();
                        const processedQuestions = api.process(data);
                        
                        if (processedQuestions && processedQuestions.length > 0) {
                            gameState.apiQuestions = processedQuestions;
                            log(`✅ Loaded ${processedQuestions.length} questions from ${api.name}`, 'success');
                            return true;
                        }
                    }
                } catch (error) {
                    log(`${api.name} failed: ${error.message}`, 'error');
                    api.working = false; // Mark as not working
                }
            }
            
            return false;
        }

        // API Processors (improved error handling)
        function processTheTriviaApi(data) {
            try {
                if (!Array.isArray(data)) return [];
                
                return data.map(q => {
                    if (!q.question || !q.correctAnswer || !Array.isArray(q.incorrectAnswers)) return null;
                    
                    const allAnswers = [q.correctAnswer, ...q.incorrectAnswers];
                    const shuffledAnswers = shuffle(allAnswers);
                    const correctIndex = shuffledAnswers.indexOf(q.correctAnswer);
                    
                    const categoryMapping = {
                        'science': 'Science',
                        'history': 'History', 
                        'geography': 'Geography',
                        'sport_and_leisure': 'Sports',
                        'film_and_tv': 'Entertainment',
                        'arts_and_literature': 'Literature',
                        'food_and_drink': 'Science',
                        'general_knowledge': 'Science',
                        'music': 'Entertainment',
                        'society_and_culture': 'History'
                    };
                    
                    return {
                        question: q.question.text || q.question,
                        options: shuffledAnswers,
                        correct: correctIndex,
                        category: categoryMapping[q.category] || 'Science',
                        source: 'the-trivia-api'
                    };
                }).filter(q => q !== null);
            } catch (error) {
                log(`Error processing The Trivia API data: ${error.message}`, 'error');
                return [];
            }
        }

        function processOpenTriviaApi(data) {
            try {
                if (data.response_code !== 0 || !Array.isArray(data.results)) return [];
                
                return data.results.map(q => {
                    if (!q.question || !q.correct_answer || !Array.isArray(q.incorrect_answers)) return null;
                    
                    const decodeHtml = (html) => {
                        const txt = document.createElement('textarea');
                        txt.innerHTML = html;
                        return txt.value;
                    };
                    
                    const allAnswers = [
                        decodeHtml(q.correct_answer),
                        ...q.incorrect_answers.map(ans => decodeHtml(ans))
                    ];
                    
                    const shuffledAnswers = shuffle(allAnswers);
                    const correctIndex = shuffledAnswers.indexOf(decodeHtml(q.correct_answer));
                    
                    const categoryMapping = {
                        'Science: Computers': 'Technology',
                        'Science: Mathematics': 'Mathematics',
                        'Science: Nature': 'Nature',
                        'Science & Nature': 'Science',
                        'Entertainment: Video Games': 'Entertainment',
                        'Entertainment: Music': 'Entertainment',
                        'Entertainment: Film': 'Entertainment',
                        'Entertainment: Television': 'Entertainment',
                        'Entertainment: Books': 'Literature',
                        'Sports': 'Sports',
                        'History': 'History',
                        'Geography': 'Geography',
                        'General Knowledge': 'Science'
                    };
                    
                    return {
                        question: decodeHtml(q.question),
                        options: shuffledAnswers,
                        correct: correctIndex,
                        category: categoryMapping[q.category] || 'Science',
                        source: 'opentdb'
                    };
                }).filter(q => q !== null);
            } catch (error) {
                log(`Error processing Open Trivia DB data: ${error.message}`, 'error');
                return [];
            }
        }

        function getNextQuestion(preferredCategory = null) {
            // Try API questions first
            if (gameState.apiQuestions.length > 0) {
                let question;
                
                if (preferredCategory) {
                    const categoryIndex = gameState.apiQuestions.findIndex(q => q.category === preferredCategory);
                    if (categoryIndex !== -1) {
                        question = gameState.apiQuestions.splice(categoryIndex, 1)[0];
                        log(`Using API question from ${preferredCategory} (${question.source})`, 'success');
                        return question;
                    }
                }
                
                question = gameState.apiQuestions.shift();
                log(`Using API question from ${question.category} (${question.source})`, 'success');
                return question;
            }
            
            // Fallback to backup questions
            if (preferredCategory && gameState.backupQuestions.length > 0) {
                const categoryQuestions = gameState.backupQuestions.filter(q => q.category === preferredCategory);
                if (categoryQuestions.length > 0) {
                    const question = categoryQuestions[0];
                    gameState.backupQuestions = gameState.backupQuestions.filter(q => q !== question);
                    log(`Using backup question from ${preferredCategory}`, 'warn');
                    return question;
                }
            }
            
            if (gameState.backupQuestions.length > 0) {
                const question = gameState.backupQuestions.shift();
                log(`Using backup question from ${question.category}`, 'warn');
                return question;
            }
            
            // Ultimate fallback
            log('Using fallback math question', 'warn');
            return { 
                question: "What is 2 + 2?", 
                options: ["3", "4", "5", "6"], 
                correct: 1, 
                category: "Mathematics",
                source: 'fallback'
            };
        }

        // ========================================
        // MODAL FUNCTIONS
        // ========================================
        
        function showUsernameModal() {
            const modal = document.getElementById('usernameModal');
            const input = document.getElementById('usernameModalInput');
            
            if (modal && input) {
                modal.classList.add('active');
                input.value = '';
                input.focus();
                
                // Handle Enter key
                input.onkeypress = function(e) {
                    if (e.key === 'Enter') {
                        confirmUsername();
                    }
                };
            }
        }

        function closeUsernameModal() {
            const modal = document.getElementById('usernameModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function confirmUsername() {
            const input = document.getElementById('usernameModalInput');
            const username = input?.value?.trim();
            
            if (!username) {
                alert("Please enter a valid username");
                return;
            }
            
            if (username.length > 20) {
                alert("Username must be 20 characters or less");
                return;
            }
            
            gameState.pendingUsername = username;
            closeUsernameModal();
            createRoom();
        }

        // ========================================
        // GLOBAL FUNCTIONS (EXPOSED TO HTML)
        // ========================================
        
        async function createRoom() {
    try {
        const username = gameState.pendingUsername;
        if (!username) {
            log('No username provided', 'error');
            return;
        }

        resetGameState();

        gameState.room = generateRoomCode();
        gameState.isHost = true;
        gameState.currentPlayer = {
            id: 'host',
            name: username,
            score: 0,
            correctAnswers: 0,
            pointsStolen: 0
        };
        gameState.players = [gameState.currentPlayer];

        // NEW: Create the room in Supabase
        const { data, error } = await supabase
            .from('rooms')
            .insert([{ code: gameState.room, status: 'waiting' }]);
        if (error) {
            log(`Error creating room in Supabase: ${error.message}`, 'error');
            alert('Failed to create room online. Please try again.');
            showScreen('homeScreen');
            return;
        }

        // Optionally, add the host as a player in Supabase as well:
        const { data: playerData, error: playerError } = await supabase
            .from('players')
            .insert([{ room_code: gameState.room, username: username, is_host: true }]);
        if (playerError) {
            log(`Error adding host to Supabase: ${playerError.message}`, 'error');
            alert('Failed to add host player online. Please try again.');
            showScreen('homeScreen');
            return;
        }

        log(`Room created: ${gameState.room}`, 'success');

        // Try to fetch API questions (don't wait)
        fetchQuestionsFromAnyApi().then(success => {
            if (success) {
                updateQuestionStatus();
            }
        });

        showLobby();

// Add this line right after showing the lobby:
    subscribeToPlayers(gameState.room);

    } catch (error) {
        log(`Error creating room: ${error.message}`, 'error');
        alert('Failed to create room. Please try again.');
        showScreen('homeScreen');
    }
}

async function joinRoom() {
    try {
        const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
        const username = document.getElementById('usernameInput').value.trim();

        if (!roomCode || roomCode.length !== 6) {
            log('Invalid room code', 'error');
            alert('Please enter a valid 6-character room code.');
            return;
        }
        if (!username) {
            log('No username provided', 'error');
            alert('Please enter your username.');
            return;
        }

        // Check if room exists in Supabase
        const { data: roomData, error: roomError } = await supabase
            .from('rooms')
            .select('*')
            .eq('code', roomCode)
            .single();
        if (roomError || !roomData) {
            log('Room not found in Supabase', 'error');
            alert('Room not found. Please check the code and try again.');
            return;
        }

        // Add player to Supabase
        const { data: playerData, error: playerError } = await supabase
            .from('players')
            .insert([{ room_code: roomCode, username: username }]);
        if (playerError) {
            log(`Error joining room in Supabase: ${playerError.message}`, 'error');
            alert('Failed to join room. Please try again.');
            return;
        }

        // Set local game state
        resetGameState();
        gameState.room = roomCode;
        gameState.isHost = false;
        gameState.currentPlayer = {
            id: 'player',
            name: username,
            score: 0,
            correctAnswers: 0,
            pointsStolen: 0
        };
        gameState.players = [gameState.currentPlayer];

        showLobby();

// Add this line right after showing the lobby:
    subscribeToPlayers(gameState.room);

    } catch (error) {
        log(`Error joining room: ${error.message}`, 'error');
        alert('Failed to join room. Please try again.');
    }
}
function subscribeToPlayers(roomCode) {
    supabase
        .channel('players')
        .on(
            'postgres_changes',
            { event: '*', schema: 'public', table: 'players', filter: `room_code=eq.${roomCode}` },
            payload => {
                fetchAndRenderPlayerList(roomCode);
            }
        )
        .subscribe();
}

async function fetchAndRenderPlayerList(roomCode) {
    const { data: players, error } = await supabase
        .from('players')
        .select('*')
        .eq('room_code', roomCode);
    if (!error) {
        renderPlayerList(players);
    }
}

function renderPlayerList(players) {
    const playerListDiv = document.getElementById('playerList');
    playerListDiv.innerHTML = '';
    players.forEach(player => {
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = player.username;
        playerListDiv.appendChild(div);
    });
}

        function showJoinScreen() {
            showScreen('joinRoomScreen');
        }

        function showHomeScreen() {
            resetGameState();
            showScreen('homeScreen');
        }

        function addComputerPlayer(difficulty = 'medium') {
            try {
                if (gameState.players.length >= CONSTANTS.MAX_PLAYERS) {
                    alert('Room is full! Maximum 12 players allowed.');
                    return;
                }
                
                const usedNames = new Set(gameState.players.map(p => p.name));
                const availableNames = COMPUTER_NAMES.filter(name => !usedNames.has(name));
                
                if (availableNames.length === 0) {
                    alert('No more computer player names available!');
                    return;
                }
                
                const computerName = getRandomElement(availableNames);
                const computerId = 'computer_' + Date.now();
                
                const difficultyEmoji = { easy: '🟢', medium: '🟡', hard: '🔴' };
                const displayName = `${computerName} ${difficultyEmoji[difficulty]}`;
                
                gameState.players.push({
                    id: computerId,
                    name: displayName,
                    score: 0,
                    correctAnswers: 0,
                    pointsStolen: 0,
                    difficulty: difficulty
                });
                
                updatePlayerList();
                updateStartButton();
                
                log(`Added ${difficulty} AI player: ${computerName}`, 'success');
                
            } catch (error) {
                log(`Error adding computer player: ${error.message}`, 'error');
            }
        }

        function shareRoom() {
            try {
                if (!gameState.room) {
                    alert('No room to share!');
                    return;
                }
                
                const shareText = `Join my Trivia Murder Party game! Room code: ${gameState.room}`;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareText)
                        .then(() => alert('Room code copied to clipboard!'))
                        .catch(() => alert(`Share this room code: ${gameState.room}`));
                } else {
                    alert(`Share this room code: ${gameState.room}`);
                }
            } catch (error) {
                log(`Error sharing room: ${error.message}`, 'error');
                alert(`Share this room code: ${gameState.room}`);
            }
        }

        function startGame() {
            try {
                if (gameState.players.length < CONSTANTS.MIN_PLAYERS) {
                    alert('Need at least 2 players to start!');
                    return;
                }
                
                if (DOM.startGameBtn) {
                    DOM.startGameBtn.disabled = true;
                    DOM.startGameBtn.textContent = 'Loading Questions...';
                }
                
                // Try to fetch fresh questions
                fetchQuestionsFromAnyApi().then(success => {
                    if (success) {
                        log('Fresh API questions loaded for game start', 'success');
                    } else {
                        log('Using backup questions for game', 'warn');
                    }
                    
                    gameState.currentRound = 1;
                    showCategorySelection();
                });
                
            } catch (error) {
                log(`Error starting game: ${error.message}`, 'error');
                alert('Failed to start game. Please try again.');
                
                if (DOM.startGameBtn) {
                    DOM.startGameBtn.disabled = false;
                    DOM.startGameBtn.textContent = 'Start Game';
                }
            }
        }

        // ========================================
        // INTERNAL FUNCTIONS
        // ========================================
        
        function showLobby() {
            showScreen('lobbyScreen');
            
            if (DOM.roomCodeDisplay) {
                DOM.roomCodeDisplay.textContent = gameState.room;
            }
            
            updatePlayerList();
            updateStartButton();
            updateQuestionStatus();
        }

        function updatePlayerList() {
            if (!DOM.playerList) return;
            
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = `Players (${gameState.players.length}/${CONSTANTS.MAX_PLAYERS})`;
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'item';
                
                let statusHTML = '';
                if (gameState.powerups.has(player.id)) {
                    statusHTML += '<span class="status powerup">💪</span>';
                }
                if (gameState.playerStatus.has(player.id)) {
                    const status = gameState.playerStatus.get(player.id);
                    statusHTML += `<span class="player-type ${status.toLowerCase()}">${status}</span>`;
                }
                
                const isCurrentPlayer = player.id === gameState.currentPlayer?.id;
                div.innerHTML = `
                    <span>${player.name}${isCurrentPlayer ? ' (You)' : ''}</span>
                    <span>${player.score} pts ${statusHTML}</span>
                `;
                fragment.appendChild(div);
            });
            
            DOM.playerList.innerHTML = '';
            DOM.playerList.appendChild(fragment);
        }

        function updateStartButton() {
            if (DOM.startGameBtn) {
                if (gameState.players.length >= CONSTANTS.MIN_PLAYERS) {
                    DOM.startGameBtn.disabled = false;
                    DOM.startGameBtn.textContent = 'Start Game';
                } else {
                    DOM.startGameBtn.disabled = true;
                    DOM.startGameBtn.textContent = `Start Game (${gameState.players.length}/${CONSTANTS.MIN_PLAYERS} players)`;
                }
            }
        }

        function updateQuestionStatus() {
            try {
                if (!DOM.playerList) return;
                
                // Remove existing status
                const existingStatus = DOM.playerList.querySelector('.question-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                const statusDiv = document.createElement('div');
                statusDiv.className = 'question-status';
                statusDiv.style.cssText = 'font-size: 0.9rem; opacity: 0.8; margin-top: 10px; text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                
                const apiCount = gameState.apiQuestions?.length || 0;
                const backupCount = gameState.backupQuestions?.length || 0;
                const workingApis = TRIVIA_APIS.filter(api => api.working === true).length;
                
                let statusText;
                if (apiCount > 0) {
                    statusText = `🌐 ${apiCount} fresh questions loaded + ${backupCount} backup questions`;
                } else if (workingApis > 0) {
                    statusText = `🌐 ${workingApis} APIs available + ${backupCount} backup questions`;
                } else {
                    statusText = `📚 Using ${backupCount} backup questions (APIs unavailable)`;
                }
                
                statusDiv.textContent = statusText;
                DOM.playerList.appendChild(statusDiv);
            } catch (error) {
                log(`Error updating question status: ${error.message}`, 'warn');
            }
        }

        function showCategorySelection() {
            showScreen('categoryScreen');
            
            const currentRoundEl = document.getElementById('currentRound');
            if (currentRoundEl) {
                currentRoundEl.textContent = gameState.currentRound;
            }
            
            gameState.flags.clear();
            
            const categoryOptions = document.getElementById('categoryOptions');
            if (!categoryOptions) return;
            
            const shuffledCategories = shuffle(CATEGORIES).slice(0, 4);
            const fragment = document.createDocumentFragment();
            
            shuffledCategories.forEach(category => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = category;
                div.onclick = () => selectCategory(category);
                fragment.appendChild(div);
            });
            
            categoryOptions.innerHTML = '';
            categoryOptions.appendChild(fragment);
            
            startTimer('categoryTimer', CONSTANTS.TIMER_DURATION.category, () => {
                if (!gameState.flags.has('categorySelected')) {
                    selectCategory(getRandomElement(shuffledCategories));
                }
            });
        }

        function selectCategory(category) {
            if (gameState.flags.has('categorySelected')) return;
            gameState.flags.add('categorySelected');
            
            document.querySelectorAll('#categoryOptions .option').forEach(opt => opt.classList.remove('selected'));
            event?.target?.classList.add('selected');
            
            setTimeout(() => generateQuestion(category), 1000);
        }

        function generateQuestion(category) {
            const question = getNextQuestion(category);
            gameState.currentQuestion = question;
            showQuestion();
        }

        function showQuestion() {
            showScreen('questionScreen');
            
            const questionRoundEl = document.getElementById('questionRound');
            if (questionRoundEl) {
                questionRoundEl.textContent = gameState.currentRound;
            }
            
            const questionTextEl = document.getElementById('questionText');
            if (questionTextEl) {
                questionTextEl.textContent = gameState.currentQuestion.question;
            }
            
            const answerOptions = document.getElementById('answerOptions');
            if (!answerOptions) return;
            
            const fragment = document.createDocumentFragment();
            gameState.currentQuestion.options.forEach((option, index) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = option;
                div.onclick = () => selectAnswer(index);
                fragment.appendChild(div);
            });
            
            answerOptions.innerHTML = '';
            answerOptions.appendChild(fragment);
            
            startTimer('questionTimer', CONSTANTS.TIMER_DURATION.question, () => {
                if (!gameState.flags.has('answerSelected')) {
                    selectAnswer(Math.floor(Math.random() * 4));
                }
            });
        }

        function selectAnswer(index) {
            if (gameState.flags.has('answerSelected')) return;
            gameState.flags.add('answerSelected');
            
            document.querySelectorAll('#answerOptions .option').forEach(opt => opt.classList.remove('selected'));
            document.querySelectorAll('#answerOptions .option')[index]?.classList.add('selected');
            
            gameState.selectedAnswers = [index];
            setTimeout(() => processAnswers(), 1000);
        }

        function processAnswers() {
            const correct = gameState.currentQuestion.correct;
            const playerAnswered = gameState.selectedAnswers[0] === correct;
            
            gameState.roundAnswers.clear();
            gameState.roundAnswers.set(gameState.currentPlayer.id, { answer: gameState.selectedAnswers[0], correct: playerAnswered });
            
            if (playerAnswered) {
                gameState.currentPlayer.score += CONSTANTS.POINTS.correct;
                gameState.currentPlayer.correctAnswers++;
                gameState.playerStatus.set(gameState.currentPlayer.id, 'W');
                log('Player answered correctly!', 'success');
            } else {
                gameState.playerStatus.set(gameState.currentPlayer.id, 'L');
                log('Player answered incorrectly', 'warn');
            }
            
            // Simulate other players with difficulty-based AI
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    let randomCorrect;
                    
                    if (player.difficulty) {
                        const correctChances = { easy: 0.3, medium: 0.5, hard: 0.7 };
                        const correctChance = correctChances[player.difficulty] || 0.5;
                        randomCorrect = Math.random() < correctChance;
                    } else {
                        randomCorrect = Math.random() < 0.5;
                    }
                    
                    const randomAnswer = randomCorrect ? correct : Math.floor(Math.random() * 4);
                    
                    gameState.roundAnswers.set(player.id, { answer: randomAnswer, correct: randomCorrect });
                    
                    if (randomCorrect) {
                        player.score += CONSTANTS.POINTS.correct;
                        player.correctAnswers++;
                        gameState.playerStatus.set(player.id, 'W');
                    } else {
                        gameState.playerStatus.set(player.id, 'L');
                    }
                }
            });
            
            if (gameState.currentRound >= CONSTANTS.POWERUP_ROUND) {
                distributePowerups();
            }
            
            showAnswers();
        }

        function distributePowerups() {
            const sortedPlayers = [...gameState.players].sort((a, b) => a.score - b.score);
            const bottomQuarter = Math.ceil(sortedPlayers.length * 0.25);
            
            for (let i = 0; i < bottomQuarter; i++) {
                gameState.powerups.set(sortedPlayers[i].id, { type: 'extraTime', description: 'Extra Time' });
            }
        }

        function showAnswers() {
            showScreen('answersScreen');
            const answersDisplay = document.getElementById('answersDisplay');
            if (!answersDisplay) return;
            
            const fragment = document.createDocumentFragment();
            
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            highlight.innerHTML = `<strong>✅ Correct Answer:</strong><br>${gameState.currentQuestion.options[gameState.currentQuestion.correct]}`;
            fragment.appendChild(highlight);
            
            const header = document.createElement('h3');
            header.textContent = 'Player Answers:';
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const playerAnswer = gameState.roundAnswers.get(player.id);
                if (!playerAnswer) return;
                
                const div = document.createElement('div');
                div.className = `item ${playerAnswer.correct ? 'correct' : 'incorrect'}`;
                const answerText = gameState.currentQuestion.options[playerAnswer.answer];
                const resultIcon = playerAnswer.correct ? '✅' : '❌';
                
                div.innerHTML = `<span>${player.name}</span><span>${resultIcon} ${answerText}</span>`;
                fragment.appendChild(div);
            });
            
            answersDisplay.innerHTML = '';
            answersDisplay.appendChild(fragment);
        }

        // ========================================
        // FIXED MINIGAME IMPLEMENTATION
        // ========================================
        
        function proceedToMinigame() {
            const winners = gameState.players.filter(p => gameState.playerStatus.get(p.id) === 'W');
            const losers = gameState.players.filter(p => gameState.playerStatus.get(p.id) === 'L');
            
            // Skip minigame if no winners or no losers
            if (winners.length === 0 || losers.length === 0) {
                log('Skipping minigame - no valid W/L split', 'warn');
                setTimeout(() => {
                    gameState.playerStatus.clear();
                    showScoreboard();
                }, 2000);
                return;
            }
            
            log(`Starting minigame: ${winners.length} winners vs ${losers.length} losers`, 'success');
            showHuntingSeasonMinigame();
        }

        function showHuntingSeasonMinigame() {
            showScreen('huntingSeasonScreen');
            gameState.minigameSelections.clear();
            
            updateHuntingPlayerStatus();
            createHuntingGrid();
            
            const playerType = gameState.playerStatus.get(gameState.currentPlayer.id);
            const instructions = document.getElementById('huntingInstructions');
            if (instructions) {
                if (playerType === 'W') {
                    instructions.textContent = "You're hunting! Pick a square to catch the losers!";
                    instructions.style.color = '#00b894';
                } else {
                    instructions.textContent = "You're being hunted! Pick a square to hide!";
                    instructions.style.color = '#e17055';
                }
            }
            
            startTimer('huntingTimer', CONSTANTS.TIMER_DURATION.hunting, () => {
                if (!gameState.minigameSelections.has(gameState.currentPlayer.id)) {
                    // Auto-select random square if player didn't choose
                    const randomSquare = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                    selectHuntingSquare(randomSquare);
                }
            });
        }

        function updateHuntingPlayerStatus() {
            const huntingPlayerStatus = document.getElementById('huntingPlayerStatus');
            if (!huntingPlayerStatus) return;
            
            const fragment = document.createDocumentFragment();
            
            const winnersDiv = document.createElement('div');
            winnersDiv.innerHTML = '<h4>🏹 Hunters (Winners):</h4>';
            const winnersContainer = document.createElement('div');
            
            const losersDiv = document.createElement('div');
            losersDiv.innerHTML = '<h4>🎯 Hunted (Losers):</h4>';
            const losersContainer = document.createElement('div');
            
            gameState.players.forEach(player => {
                const status = gameState.playerStatus.get(player.id);
                const div = document.createElement('div');
                div.className = 'item';
                div.innerHTML = `<span>${player.name}</span><span>${player.score} pts</span>`;
                
                if (status === 'W') {
                    div.style.background = 'rgba(0, 184, 148, 0.3)';
                    winnersContainer.appendChild(div);
                } else if (status === 'L') {
                    div.style.background = 'rgba(225, 112, 85, 0.3)';
                    losersContainer.appendChild(div);
                }
            });
            
            fragment.appendChild(winnersDiv);
            fragment.appendChild(winnersContainer);
            fragment.appendChild(losersDiv);
            fragment.appendChild(losersContainer);
            
            huntingPlayerStatus.innerHTML = '';
            huntingPlayerStatus.appendChild(fragment);
        }

        function createHuntingGrid() {
            const huntingGrid = document.getElementById('huntingGrid');
            if (!huntingGrid) return;
            
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = i + 1;
                cell.onclick = () => selectHuntingSquare(i);
                fragment.appendChild(cell);
            }
            
            huntingGrid.innerHTML = '';
            huntingGrid.appendChild(fragment);
        }

        function selectHuntingSquare(index) {
            if (gameState.minigameSelections.has(gameState.currentPlayer.id)) return;
            
            // Clear previous selection visuals
            document.querySelectorAll('#huntingGrid .grid-cell').forEach(cell => cell.classList.remove('selected'));
            
            // Mark current selection
            const selectedCell = document.querySelectorAll('#huntingGrid .grid-cell')[index];
            if (selectedCell) {
                selectedCell.classList.add('selected');
            }
            
            gameState.minigameSelections.set(gameState.currentPlayer.id, index);
            log(`Player selected square ${index + 1}`, 'success');
            
            // Simulate AI player selections
            simulateAIMinigameSelections();
            
            // Process results after slight delay
            setTimeout(() => processMinigameResults(), 1500);
        }

        function simulateAIMinigameSelections() {
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id && !gameState.minigameSelections.has(player.id)) {
                    // AI makes strategic choices based on difficulty
                    let choice;
                    if (player.difficulty === 'hard') {
                        // Hard AI tries to avoid corners and center
                        const avoidSquares = [0, 3, 12, 15, 5, 6, 9, 10]; // corners and center-ish
                        const safeSquares = Array.from({length: CONSTANTS.GRID_SIZE}, (_, i) => i).filter(i => !avoidSquares.includes(i));
                        choice = getRandomElement(safeSquares);
                    } else if (player.difficulty === 'easy') {
                        // Easy AI just picks randomly
                        choice = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                    } else {
                        // Medium AI has some strategy
                        choice = Math.floor(Math.random() * CONSTANTS.GRID_SIZE);
                        if (Math.random() < 0.3) { // 30% chance to pick edge squares
                            const edgeSquares = [1, 2, 4, 7, 8, 11, 13, 14];
                            choice = getRandomElement(edgeSquares);
                        }
                    }
                    
                    gameState.minigameSelections.set(player.id, choice);
                }
            });
        }

        function processMinigameResults() {
            const results = [];
            const winnerSelections = new Map();
            const loserSelections = new Map();
            
            // Separate selections by player type
            gameState.players.forEach(player => {
                const selection = gameState.minigameSelections.get(player.id);
                const status = gameState.playerStatus.get(player.id);
                
                if (status === 'W') {
                    winnerSelections.set(player.id, selection);
                } else if (status === 'L') {
                    loserSelections.set(player.id, selection);
                }
            });
            
            // Check for collisions
            winnerSelections.forEach((winnerSquare, winnerId) => {
                loserSelections.forEach((loserSquare, loserId) => {
                    if (winnerSquare === loserSquare) {
                        // Collision! Winner steals from loser
                        const winner = gameState.players.find(p => p.id === winnerId);
                        const loser = gameState.players.find(p => p.id === loserId);
                        
                        if (loser.score > 0) {
                            loser.score -= 1;
                            winner.score += 1;
                            winner.pointsStolen = (winner.pointsStolen || 0) + 1;
                            results.push(`${winner.name} caught ${loser.name} on square ${winnerSquare + 1}! (1 point stolen)`);
                        } else {
                            winner.score += 1;
                            winner.pointsStolen = (winner.pointsStolen || 0) + 1;
                            results.push(`${winner.name} caught ${loser.name} on square ${winnerSquare + 1}! (1 point gained)`);
                        }
                    }
                });
            });
            
            if (results.length === 0) {
                results.push('No collisions! All players escaped safely.');
            }
            
            showMinigameResults(results, winnerSelections, loserSelections);
        }

        function showMinigameResults(results, winnerSelections, loserSelections) {
            showScreen('minigameResultsScreen');
            
            const minigameResults = document.getElementById('minigameResults');
            if (!minigameResults) return;
            
            const fragment = document.createDocumentFragment();
            
            // Show the grid with results
            const gridContainer = document.createElement('div');
            gridContainer.innerHTML = '<h3>Final Grid Results:</h3>';
            
            const resultGrid = document.createElement('div');
            resultGrid.className = 'grid';
            resultGrid.style.margin = '15px auto';
            
            for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = i + 1;
                
                // Check if square was selected
                const winnerHere = Array.from(winnerSelections.entries()).find(([_, square]) => square === i);
                const loserHere = Array.from(loserSelections.entries()).find(([_, square]) => square === i);
                
                if (winnerHere && loserHere) {
                    cell.classList.add('collision');
                    cell.textContent = '💥';
                } else if (winnerHere) {
                    cell.classList.add('winner');
                    cell.textContent = '🏹';
                } else if (loserHere) {
                    cell.classList.add('loser');
                    cell.textContent = '🎯';
                }
                
                resultGrid.appendChild(cell);
            }
            
            gridContainer.appendChild(resultGrid);
            fragment.appendChild(gridContainer);
            
            // Show results text
            const resultsHeader = document.createElement('h3');
            resultsHeader.textContent = 'Hunt Results:';
            fragment.appendChild(resultsHeader);
            
            results.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'highlight';
                resultDiv.style.fontSize = '0.9rem';
                resultDiv.textContent = result;
                fragment.appendChild(resultDiv);
            });
            
            minigameResults.innerHTML = '';
            minigameResults.appendChild(fragment);
            
            // Clear selections for next round
            gameState.minigameSelections.clear();
        }

        function showScoreboard() {
            showScreen('scoreboardScreen');
            updateScoreboard();
            
            const nextBtn = document.getElementById('nextRoundBtn');
            if (nextBtn) {
                if (gameState.currentRound >= CONSTANTS.FINAL_ROUND) {
                    nextBtn.textContent = 'Final Round';
                    nextBtn.onclick = () => showFinalRound();
                } else {
                    nextBtn.textContent = 'Next Round';
                    nextBtn.onclick = () => nextRound();
                }
            }
        }

        function updateScoreboard() {
            const scoreboard = document.getElementById('scoreboard');
            if (!scoreboard) return;
            
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = `Round ${gameState.currentRound} Standings`;
            fragment.appendChild(header);
            
            sortedPlayers.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `item ${index === 0 ? 'winner' : ''}`;
                
                const powerupHTML = gameState.powerups.has(player.id) ? '<span class="status powerup">💪</span>' : '';
                
                div.innerHTML = `
                    <span>${index + 1}. ${player.name}</span>
                    <span>${player.score} pts ${powerupHTML}</span>
                `;
                fragment.appendChild(div);
            });
            
            scoreboard.innerHTML = '';
            scoreboard.appendChild(fragment);
        }

        function nextRound() {
            gameState.currentRound++;
            gameState.selectedAnswers = [];
            gameState.playerStatus.clear(); // Clear W/L status for next round
            showCategorySelection();
        }

        function showFinalRound() {
            showScreen('finalRoundScreen');
            
            const finalQuestionText = document.getElementById('finalQuestionText');
            if (finalQuestionText) {
                finalQuestionText.textContent = FINAL_ROUND_QUESTION.question;
            }
            
            const finalOptions = document.getElementById('finalOptions');
            if (!finalOptions) return;
            
            const fragment = document.createDocumentFragment();
            FINAL_ROUND_QUESTION.options.forEach((option, index) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.textContent = option;
                div.onclick = () => selectFinalAnswer(index);
                fragment.appendChild(div);
            });
            
            finalOptions.innerHTML = '';
            finalOptions.appendChild(fragment);
            
            gameState.selectedAnswers = [];
            
            startTimer('finalTimer', CONSTANTS.TIMER_DURATION.final, () => {
                if (gameState.selectedAnswers.length === 0) {
                    // Auto-select two random answers
                    const randomAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                    gameState.selectedAnswers = randomAnswers;
                }
                processFinalAnswers();
            });
        }

        function selectFinalAnswer(index) {
            if (gameState.selectedAnswers.includes(index)) {
                // Deselect
                gameState.selectedAnswers = gameState.selectedAnswers.filter(a => a !== index);
                document.querySelectorAll('#finalOptions .option')[index].classList.remove('selected');
            } else if (gameState.selectedAnswers.length < 2) {
                // Select (max 2)
                gameState.selectedAnswers.push(index);
                document.querySelectorAll('#finalOptions .option')[index].classList.add('selected');
            }
            
            // Auto-proceed if exactly 2 selected
            if (gameState.selectedAnswers.length === 2) {
                setTimeout(() => processFinalAnswers(), 1000);
            }
        }

        function processFinalAnswers() {
            const correctAnswers = FINAL_ROUND_QUESTION.correct;
            const playerCorrect = gameState.selectedAnswers.filter(a => correctAnswers.includes(a)).length;
            
            let points = 0;
            if (playerCorrect === 2) {
                points = CONSTANTS.POINTS.finalFull;
            } else if (playerCorrect === 1) {
                points = CONSTANTS.POINTS.finalPartial;
            }
            
            gameState.currentPlayer.score += points;
            gameState.finalAnswers.set(gameState.currentPlayer.id, { 
                answers: gameState.selectedAnswers, 
                correct: playerCorrect, 
                points: points 
            });
            
            // Simulate other players
            gameState.players.forEach(player => {
                if (player.id !== gameState.currentPlayer.id) {
                    let aiAnswers;
                    if (player.difficulty === 'hard') {
                        // Hard AI has 70% chance to get both right
                        if (Math.random() < 0.7) {
                            aiAnswers = [...correctAnswers];
                        } else if (Math.random() < 0.8) {
                            aiAnswers = [correctAnswers[0], Math.floor(Math.random() * 5)];
                        } else {
                            aiAnswers = [Math.floor(Math.random() * 5), Math.floor(Math.random() * 5)];
                        }
                    } else if (player.difficulty === 'easy') {
                        // Easy AI mostly random
                        aiAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                    } else {
                        // Medium AI has 40% chance to get both right
                        if (Math.random() < 0.4) {
                            aiAnswers = [...correctAnswers];
                        } else if (Math.random() < 0.6) {
                            aiAnswers = [correctAnswers[0], Math.floor(Math.random() * 5)];
                        } else {
                            aiAnswers = shuffle([0, 1, 2, 3, 4]).slice(0, 2);
                        }
                    }
                    
                    const aiCorrect = aiAnswers.filter(a => correctAnswers.includes(a)).length;
                    let aiPoints = 0;
                    if (aiCorrect === 2) {
                        aiPoints = CONSTANTS.POINTS.finalFull;
                    } else if (aiCorrect === 1) {
                        aiPoints = CONSTANTS.POINTS.finalPartial;
                    }
                    
                    player.score += aiPoints;
                    gameState.finalAnswers.set(player.id, { 
                        answers: aiAnswers, 
                        correct: aiCorrect, 
                        points: aiPoints 
                    });
                }
            });
            
            showFinalAnswers();
        }

        function showFinalAnswers() {
            showScreen('finalAnswersScreen');
            
            const finalAnswersDisplay = document.getElementById('finalAnswersDisplay');
            if (!finalAnswersDisplay) return;
            
            const fragment = document.createDocumentFragment();
            
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            const correctOptions = FINAL_ROUND_QUESTION.correct.map(i => FINAL_ROUND_QUESTION.options[i]);
            highlight.innerHTML = `<strong>✅ Correct Answers:</strong><br>${correctOptions.join(' and ')}`;
            fragment.appendChild(highlight);
            
            const header = document.createElement('h3');
            header.textContent = 'Final Round Results:';
            fragment.appendChild(header);
            
            gameState.players.forEach(player => {
                const playerResult = gameState.finalAnswers.get(player.id);
                if (!playerResult) return;
                
                const div = document.createElement('div');
                let className = 'item ';
                if (playerResult.correct === 2) {
                    className += 'correct';
                } else if (playerResult.correct === 1) {
                    className += 'partially-correct';
                } else {
                    className += 'incorrect';
                }
                div.className = className;
                
                const playerAnswers = playerResult.answers.map(i => FINAL_ROUND_QUESTION.options[i]);
                const resultText = `${playerResult.correct}/2 correct (+${playerResult.points} pts)`;
                
                div.innerHTML = `
                    <div>
                        <strong>${player.name}</strong><br>
                        <small>${playerAnswers.join(', ')}</small>
                    </div>
                    <span>${resultText}</span>
                `;
                fragment.appendChild(div);
            });
            
            finalAnswersDisplay.innerHTML = '';
            finalAnswersDisplay.appendChild(fragment);
        }

        function showFinalResults() {
            showScreen('finalResultsScreen');
            
            const finalScoreboard = document.getElementById('finalScoreboard');
            if (!finalScoreboard) return;
            
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            const fragment = document.createDocumentFragment();
            
            const header = document.createElement('h3');
            header.textContent = '🏆 Championship Results';
            fragment.appendChild(header);
            
            sortedPlayers.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `item ${index === 0 ? 'winner' : ''}`;
                
                const rank = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                
                div.innerHTML = `
                    <div>
                        <strong>${rank} ${player.name}</strong>
                        <br>
                        <small>Correct: ${player.correctAnswers} | Stolen: ${player.pointsStolen || 0}</small>
                    </div>
                    <div>
                        <strong>${player.score} pts</strong>
                    </div>
                `;
                fragment.appendChild(div);
            });
            
            finalScoreboard.innerHTML = '';
            finalScoreboard.appendChild(fragment);
        }

        function playAgain() {
            if (confirm('Start a new game with the same players?')) {
                gameState.players.forEach(player => {
                    player.score = 0;
                    player.correctAnswers = 0;
                    player.pointsStolen = 0;
                });
                
                gameState.currentRound = 1;
                gameState.playerStatus.clear();
                gameState.powerups.clear();
                gameState.backupQuestions = [...BACKUP_QUESTIONS];
                
                // Fetch fresh questions
                fetchQuestionsFromAnyApi();
                
                showLobby();
            }
        }

        function startTimer(timerId, seconds, callback) {
            if (gameState.currentTimer) {
                clearInterval(gameState.currentTimer);
            }
            
            const timerElement = document.getElementById(timerId);
            if (!timerElement) return;
            
            let timeLeft = seconds;
            
            // Apply powerup if available
            if (gameState.powerups.has(gameState.currentPlayer?.id)) {
                const powerup = gameState.powerups.get(gameState.currentPlayer.id);
                if (powerup.type === 'extraTime') {
                    timeLeft += 5;
                    gameState.powerups.delete(gameState.currentPlayer.id);
                    log('Extra time powerup applied!', 'success');
                }
            }
            
            timerElement.textContent = timeLeft;
            timerElement.style.color = '#ff6b6b';
            
            gameState.currentTimer = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(gameState.currentTimer);
                    gameState.currentTimer = null;
                    callback();
                }
            }, 1000);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        
        document.addEventListener('DOMContentLoaded', () => {
            log('🎮 Trivia Murder Party Loading...');
            
            // Cache DOM elements
            cacheDOM();
            
            // Check critical elements
            const criticalElements = ['homeScreen', 'lobbyScreen', 'categoryScreen', 'questionScreen'];
            const missingElements = criticalElements.filter(id => !document.getElementById(id));
            
            if (missingElements.length > 0) {
                log(`Missing critical elements: ${missingElements.join(', ')}`, 'error');
                return;
            }
            
            // Handle URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            if (roomCode) {
                const roomInput = document.getElementById('roomCodeInput');
                if (roomInput) {
                    roomInput.value = roomCode;
                    showScreen('joinRoomScreen');
                }
            }
            
            // Test all APIs on load
            setTimeout(() => {
                testAllApis();
            }, 1000);
            
            log('🎮 Trivia Murder Party Initialized!', 'success');
        });

        // Global error handlers
        window.addEventListener('error', (event) => {
            log(`Global error: ${event.error?.message || event.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            log(`Unhandled promise rejection: ${event.reason}`, 'error');
        });

        // Prevent zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) event.preventDefault();
            lastTouchEnd = now;
        }, { passive: false });

        // Page visibility handling
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    log('Game paused (page hidden)');
                }
            } else {
                log('Game resumed (page visible)');
            }
        });
    
// ====== REAL-TIME SUBSCRIPTIONS AND SUPABASE SYNC PATCHES ======

// Subscribe helpers
function subscribeToGameState(roomCode) {
  supabase
    .channel('game_state')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.phase = payload.new.phase;
        renderPhaseScreen(payload.new.phase);
      })
    .subscribe();
}

function subscribeToMinigamePicks(roomCode) {
  supabase
    .channel('minigame_picks')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'minigame_picks', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.minigameSelections.set(payload.new.player_id, payload.new.pick);
        checkAllPicksAndContinue?.(); // Define this handler
      })
    .subscribe();
}

function subscribeToAnswers(roomCode) {
  supabase
    .channel('answers')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'answers', filter: `room_code=eq.${roomCode}` },
      payload => {
        gameState.roundAnswers.set(payload.new.player_id, { answer: payload.new.answer, correct: payload.new.correct });
        maybeAdvancePhaseIfAllAnswered?.(); // Define this handler
      })
    .subscribe();
}

// Call these subscriptions on join/create
// After subscribeToPlayers(gameState.room);
subscribeToGameState(gameState.room);
subscribeToMinigamePicks(gameState.room);
subscribeToAnswers(gameState.room);

</script>
</body>
</html>